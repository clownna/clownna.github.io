[{"title":"常见特殊符号","slug":"常见特殊符号","date":"2020-04-22T07:17:03.000Z","updated":"2020-04-22T07:22:40.161Z","comments":true,"path":"2020/04/22/常见特殊符号/","link":"","permalink":"http://yoursite.com/2020/04/22/常见特殊符号/","excerpt":"","text":"符号 描述 编码 ≠ not equal &amp;ne; ≤ less or equal &amp;le; ≥ greater or equal &amp;ge; &lt; less-than &amp;lt; &gt; greater-than &amp;gt; “ quotation mark &amp;quot; ‘ apostrophe &amp;apos; &amp; ampersand &amp;amp; © copyright &amp;copy; ® registered trademark &amp;reg; 参考网址","categories":[],"tags":[]},{"title":"vue学习笔记","slug":"vue学习笔记","date":"2020-04-22T07:15:13.000Z","updated":"2020-04-22T07:24:48.979Z","comments":true,"path":"2020/04/22/vue学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/vue学习笔记/","excerpt":"1. vue安装：","text":"1. vue安装： vue devtools浏览器扩展插件：方便调试vue应用。 方式1：直接引入vue.js文件（绝对路径与相对路径都可）。 方式2：vue-cli：脚手架：生成项目的相关相关配置和依赖 2. vue介绍：Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。 声明式：依据一定语法直接写对应代码命令式：整个流程自己写 作用：从后台获取数据动态地渲染在前台界面（响应式：DOM与数据关联）渐进式js库：1.核心库 2.插件（功能） 模式：MVVM ———————————ViewModel—————————— ——————DOM Listeners（DOM监听）—————–&gt; View————————————————————– Model &lt;—————–Data Blindings（数据绑定）——————–视图（模板页面）DOM —————————-模型（数据对象）data(模板：动态页面)—————Vue示例（vm）————————— 3. 模板语法：1.指令 举例： v-mind：强制数据绑定（可以将常量，如字符串变成变量） 简写：在属性的左侧加冒号（：） v-on：事件名（绑定事件监听） 简写：@事件名 v-model：单向/双向数据绑定（一般在写input时用到） 2.大括号表达式 4. 计算属性和监视：1.计算属性： 基本：computed，写计算属性方法 高级：调用get（），set（） 2.监视： watch配置 vm对象的$watch() 5. class与style绑定6. 条件渲染：v-ifv-else会直接移除标签v-show通过样式display：none来隐藏 比较v-if与v-show：如果需要频繁切换 v-show 较好 7. 列表渲染：v-for 8. 事件处理：","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"JSON学习笔记","slug":"JSON学习笔记","date":"2020-04-22T07:11:22.000Z","updated":"2020-04-22T07:12:06.438Z","comments":true,"path":"2020/04/22/JSON学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/JSON学习笔记/","excerpt":"6. JSON：","text":"6. JSON： JS中的对象只有JS自己认识，其他的语言都不认识 JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用于数据的交互 JSON JavaScript Object Notation JS对象表示法 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号，其他的和JS语法一致 JSON分类： 1.对象 {}2.数组 []如：var json = ‘{“name”:”孙悟空”,”age”:18,”gender”:”男”}’;//两个注意的点：1.JSON是字符串，需要用括号括起来；2.属性名必须加双引号 JSON中允许的值： 1.字符串2.数值3.布尔值4.null5.对象（普通对象，不包括函数）6.数组 JSON与JS对象互相转换： 在JS中，为我们提供了一个工具类，就叫JSON，这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON - json --&gt; js对象 JSON.parse() - 可以将以JSON字符串转换为js对象 - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 - JS对象 ---&gt; JSON JSON.stringify() - 可以将一个JS对象转换为JSON字符串 - 需要一个js对象作为参数，会返回一个JSON字符串如果需要兼容IE7及以下的JSON操作，则可以通过引入一个外部的js文件来处理 eval() 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块，如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 举例： 123var str = '&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;';var obj = eval(\"(\"+str+\")\");console.log(obj);","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"DOM学习笔记","slug":"DOM学习笔记","date":"2020-04-22T07:09:04.000Z","updated":"2020-04-22T07:33:37.613Z","comments":true,"path":"2020/04/22/DOM学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/DOM学习笔记/","excerpt":"4. DOM:","text":"4. DOM: Document Object Model 文档对象模型，通过DOM可以来任意地修改网页中各个内容 文档 文档指的是网页，一个网页就是一个文档 对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了 模型 模型用来表示节点和节点之间的关系，方便操作页面 节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 节点的属性： 类型 nodeName nodeType nodeVaule 文档节点 #document 9 null 元素节点 标签名 1 null 属性节点 属性名 2 属性值 文本节点 #text 3 文本内容 DOM操作 DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(“id属性值”); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(“name属性值”);//表单项 根据标签名来查询一组元素节点对象： document.getElementsByTagName(“标签名”);//getElementsByName和getElementsByTagName返回一个类数组对象，所有查询到的元素会封装到数组对象中 element元素的属性： 读取元素的属性： 语法：元素.属性名 例子： ele.name ele.id ele.value ele.className（class属性） 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码（对于自结束标签没有意义） 事件（Event） 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动等 我们可以为事件来绑定回调函数来响应事件。当事件被触发时函数执行响应。在事件的响应函数中，响应函数是被谁绑定的this就是谁。 绑定事件的方式： 1.可以在标签的事件属性中设置相应的JS代码（耦合） 例子：&lt;button onclick=&quot;js代码。。。&quot;&gt;按钮&lt;/button&gt; 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件（推荐使用） 例子：1234var btn = document.getElementById(\"btn\");btn.onclick = function()&#123;&#125;; 事件对象 当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向等 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有作为实参传递，而是作为window对象的属性保存 例子：1234元素.事件 = function(event)&#123; event = event || window.event;//解决兼容性问题 &#125;; 事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡例子：12345元素.事件 = function(event)&#123; event = event || window.event; event.cancelBubble = true;&#125;; 事件的委派： 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。 绑定了祖先元素要考虑到祖先元素的作用范围target：event事件中的target表示的触发事件的对象，通过判断target对象是否是希望作用的对象来指定范围。 事件的绑定： 使用 对象.事件 = 函数 的形式绑定响应函数，它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的 addEventListener() 通过这个方法也可以为元素绑定响应函数 参数： 1.事件的字符串，不要on（如onclick写成click） 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行。这个方法不支持IE8及以下的浏览器 attachEvent() 在IE8及以下的浏览器中可以使用attachEvent()来绑定事件 参数： 1.事件的字符串，要on 2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是先执行后绑定的，执行顺序和addEventListener()相反 定义一个函数，用来为指定元素绑定响应函数（兼容不同浏览器） 12345678910111213141516171819202122232425262728293031/* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj);//addEventListener()中的this，是绑定事件的对象//attachEvent()中的this，是window。我们希望两个this都是绑定事件的对象，this是谁由调用方式决定，通过call()方法重新指定this &#125;); &#125; &#125; 事件的传播： 关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素，也就是说事件应该在捕获阶段执行。W3C综合了两个公司的方案，将事件传播分成了三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true。一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 解决方式二： 将js代码编写到window.onload = function(){}中(为window绑定一个onload事件) window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 其他DOM查询 通过具体的元素节点来查询 元素.getElementsByTagName() 通过标签名查询当前元素的指定后代元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点//DOM会将标签间的空白也当成文本节点，但是在IE8及以下浏览器不会 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点（包括空白子节点） 元素.firstElementChild 获取当前元素的第一个子元素（但是不兼容IE8及以下的浏览器） 元素.lastChild 获取当前元素的最后一个子节点（包括空白子节点） 元素.lastElementChild 获取当前元素的最后一个子元素（但是不兼容IE8及以下的浏览器） 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点（包括空白子节点） 元素.previousElementSibling 获取当前元素的前一个兄弟元素（但是不兼容IE8及以下的浏览器） 元素.nextSibling 获取当前元素的后一个兄弟节点（包括空白子节点） 元素.nextElementSibling 获取当前元素的后一个兄弟元素（但是不兼容IE8及以下的浏览器） 元素.classList[.add() | .remove()] classList 属性返回元素的类名 该属性用于在元素中添加，移除及切换 CSS 类。 classList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。 innerHTML和innerText 这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性 两个属性作用类似，都可以获取到标签内部的内容， 不同是innerHTML会获取到html标签，而innerText会自动去除标签 如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容也可以使用以下方法： h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法 document.all - 获取页面中的所有元素，相当于document.getElementsByTagName(&quot;*&quot;); document.documentElement - 获取页面中html根元素 document.body - 获取页面中的body元素 document.getElementsByClassName() - 根据元素的class属性值查询一组元素节点对象 - 这个方法不支持IE8及以下的浏览器 document.querySelector() - 根据CSS选择器去页面中查询一个元素节点对象 - 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() - 根据CSS选择器去页面中查询一组元素节点对象 - 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 DOM修改 document.createElement() - 可以根据标签名创建一个元素节点对象 document.createTextNode() - 可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) - 向父节点中添加指定的子节点 父节点.insertBefore(新节点,旧节点) - 将一个新的节点插入到旧节点的前边 父节点.replaceChild(新节点,旧节点) - 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) - 删除指定的子节点 - 推荐方式：子节点.parentNode.removeChild(子节点) //当我们不知道父节点是谁的时候 DOM对CSS的操作 读取和修改内联样式 使用style属性来操作元素的内联样式 读取内联样式：（注意只能是内联样式） 语法：元素.style.样式名 例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法 将-去掉，-后的字母改大写 比如：background-color –&gt; backgroundColor - 修改内联样式： 语法：元素.style.样式名 = 样式值 - 通过style修改的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 但是上面的操作会使行为和表现耦合，且修改一个样式，浏览器就需要重新渲染一次页面，这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便。一般采用直接修改className的方式。 定义一个函数，用来向一个元素中添加或删除指定的class属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 */function addClass(obj , cn)&#123; //检查obj中是否含有cn if(!hasClass(obj , cn))&#123; obj.className += \" \"+cn;//+=是因为我们要保持原本的class &#125;&#125;/** 判断一个元素中是否含有指定的class属性值* 如果有该class，则返回true，没有则返回false*/function hasClass(obj , cn)&#123; //判断obj中有没有cn这个class //创建一个正则表达式 //var reg = /\\bcn\\b/;//这种写法不行，以为cn会被判断成一个常量，而不是一个变量，所以使用下面的写法 var reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\"); return reg.test(obj.className);&#125;/** 删除一个元素中的指定的class属性*/function removeClass(obj , cn)&#123; //创建一个正则表达式 var reg = new RegExp(\"\\\\b\"+cn+\"\\\\b\"); //删除class obj.className = obj.className.replace(reg , \"\");&#125;/** toggleClass可以用来切换一个类* 如果元素中具有该类，则删除* 如果元素中没有该类，则添加*/function toggleClass(obj , cn)&#123; //判断obj中是否含有cn if(hasClass(obj , cn))&#123; //有，则删除 removeClass(obj , cn); &#125;else&#123; //没有，则添加 addClass(obj , cn); &#125;&#125; 读取元素的当前样式（正在显示的样式） 除了IE8及以下的其他浏览器： 使用getComputedStyle()（没有对应样式则获取到真实值） 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[&quot;width&quot;];//变量的方式 [ ] getComputedStyle(box , null).width;//值的方式 . 通过该方法读取到样式都是只读的不能修改 IE8（只有它支持） 使用currentStyle（没有对应样式则获取到默认值） 语法： 元素.currentStyle.样式名 元素.currentStyle[“样式名”] 通过这个属性读取到的样式是只读的不能修改 自定义支持所有浏览器函数获取css样式： 123456789101112131415161718/* * 定义一个函数，用来获取指定元素的当前的样式 * 参数： * obj 要获取样式的元素 * name 要获取的样式名 */function getStyle(obj , name)&#123; if(window.getComputedStyle)&#123; //添加window是对象的属性，没有定义返回undefined，不添加window是变量，没有定义会报错。 //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; &#125;else&#123; //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; &#125; //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];//简写方式&#125; 所有涉及到兼容性问题（有的浏览器没有某个方法）都可以这么写。 读取其他的样式相关的属性 注意：以下样式都是只读的，且是纯数字 clientHeight - 元素的可见高度，指元素的内容区和内边距的高度 clientWidth - 元素的可见宽度，指元素的内容区和内边距的宽度 offsetHeight - 整个元素的高度，包括内容区、内边距、边框 offfsetWidth - 整个元素的宽度，包括内容区、内边距、边框 offsetParent - 当前元素的定位父元素 - 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body offsetLeft offsetTop - 当前元素和定位父元素之间的偏移量 - offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeight scrollWidth - 获取元素滚动区域的高度和宽度 scrollTop scrollLeft - 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动 scrollHeight - scrollTop = clientHeight 水平滚动 scrollWidth - scrollLeft = clientWidth","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"BOM学习笔记","slug":"BOM学习笔记","date":"2020-04-22T07:07:19.000Z","updated":"2020-04-22T07:08:37.139Z","comments":true,"path":"2020/04/22/BOM学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/BOM学习笔记/","excerpt":"5. BOM：","text":"5. BOM： 浏览器对象模型 BOM可以使我们通过JS来操作浏览器 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的是当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页。而且该操作只在当次访问时有效。 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用（window可以省略） 5.1 Windowwindow相关方法： setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次2.每次调用间隔的时间，单位是毫秒 返回值：返回一个Number类型的数据，这个数据用来作为定时器的唯一标识。 clearInterval() 可以用来关闭一个定时器 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 setTimeout() 延时调用（用法与定时一样） 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次。 clearTimeout(); 关闭延时调用（用法与定时一样） 5.2 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent 判断不同浏览器： 1234567891011121314151617181920var ua = navigator.userAgent;console.log(ua);if(/firefox/i.test(ua))&#123; alert(\"你是火狐\");&#125;else if(/chrome/i.test(ua))&#123; alert(\"你是Chrome\");&#125;else if(/msie/i.test(ua))&#123; alert(\"你是IE浏览器\");&#125;else if(\"ActiveXObject\" in window)&#123;//判断浏览器是否含有ActiveXObject //如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如：ActiveXObject（IE特有） alert(\"你是IE11\");&#125; 5.3 History 该对象可以用来操作浏览器向前或向后翻页length 属性，可以获取到当次访问的链接数量 back() - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 - 如：history.back();forward() - 可以跳转下一个页面，作用和浏览器的前进按钮一样 go() - 可以用来跳转到指定的页面 - 它需要一个整数作为参数 1:表示向前跳转一个页面 相当于forward() 2:表示向前跳转两个页面 1:表示向后跳转一个页面 -2:表示向后跳转两个页面 … 5.4 Location 该对象中封装了浏览器的地址栏的信息 如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径） 如果直接将location属性修改为一个完整的路径，或相对路径则页面会自动跳转到该路径，并且会生成相应的历史记录 assign() 用来跳转到其他的页面，作用和直接修改location一样(也会生成相应的历史记录) reload() 用于重新加载当前页面，作用和刷新按钮一样 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面 replace() 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面不会生成历史记录，不能使用回退按钮回退。","categories":[],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://yoursite.com/tags/BOM/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"JavaScript(ES)学习笔记","slug":"JavaScript-ES-学习笔记","date":"2020-04-22T07:03:53.000Z","updated":"2020-04-22T07:13:47.682Z","comments":true,"path":"2020/04/22/JavaScript-ES-学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/JavaScript-ES-学习笔记/","excerpt":"1. 语言概念：","text":"1. 语言概念： 计算机语言是与计算机交流的工具，具有功能指令的语句组成了程序，编写计算机语言程序即编程。现在用到的一般是现代语言（即高级语言），其语法与人类语言类似。需要编译的语言会再转换成计算机能够识别的二进制编码。 2. JavaScript简介：2.1 起源：JavaScript一开始是为了进行前端验证 （即检查用户输入内容是否符合一定规则），后来也用于实现页面动态效果。 为了确保不同浏览器运行的JavaScript标准一致，现在使用的JavaScript都是遵循ECMAScript标准，简称ES。 不同浏览器用到的js引擎不同，即实现js的方式不同。 2.2 组成：JavaScript：ES+DOM+BOM 2.3 特点：JavaScript负责页面中的的行为。它是一门运行在浏览器端的脚本语言。 1.解释型语言（无需编译）2.动态语言3.基于原型的面向对象 3. JavaScript语法：(ES)3.1 编写位置（从上到下执行）：1.可以编写到标签的指定属性中：结构与行为耦合，不方便维护（不推荐使用） 12&lt;button onclick=\"alert('hello');\"&gt;按钮&lt;/button&gt;&lt;a href=\"javascript:alert('hello');\"&gt;超链接&lt;/a&gt; 2.可以编写到script标签中： 123&lt;script type=\"text/javascript\"&gt;//编写js代码&lt;/script&gt; 3.可以将代码编写到外部的js文件中，然后通过标签将其引入：写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制（推荐使用的方式）。script标签一旦用于引入外部文件了，就不能在其中编写代码了。可以创建一个新的script标签用于编写内部代码。 1&lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 3.2 输出语句：常用于（BUG）调试。 alert(“要输出的内容”);- 该语句会在浏览器窗口中弹出一个警告框 document.write(“要输出的内容”);- 该内容将会被写到body标签中，并在页面中显示 console.log(“要输出的内容”);- 该内容会被写到开发者工具的控制台中 prompt(“请输入内容：”)：- 可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串将会作为提示框的提示文字。用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容。 - 返回的值是string类型。可以直接在函数前加+，转换成number： var num = +prompt(&quot;请输入一个数字：&quot;) alert(typeof num); //number confirm(“确认要删除吗？”);- 带有确认和取消按钮的弹窗 - 如果用户点击确认，返回true；点击取消，返回false。 3.3 js注释： 单行注释：//注释内容 多行注释：/*注释内容 */ 3.4 编写规则： JS严格区分大小写 JS中每条语句以分号(;)结尾 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 3.5 字面量和变量： 字面量- 固定的值，比如 1 true false null NaN &quot;hello&quot; 字面量都是不可以改变的。 - 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量- 变量可以用来保存任意的字面量 - 一般都是通过变量来使用字面量，而不直接使用字面量，还可以通过变量来对字面量进行描述 - 声明变量：使用var关键字来声明一个变量 var a; - 为变量赋值： a = 1; - 声明和赋值同时进行： var a = 1; 3.6 标识符： 在JS中所有的可以自主命名的内容，都可以认为是一个标识符 比如：变量名、函数名、属性名 标识符需要遵守一定的规范： 1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是JS中的关键字和保留字4.标识符一般采用驼峰命名法（helloWorld） 3.7 数据类型(字面量的类型)： JS中一共分成六种数据类型 - String 字符串 - Number 数值 - Boolean 布尔值 - Null 空值 - Undefined 未定义 - Object 对象 其中基本数据类型有 String 字符串 - JS中的字符串需要使用双引号或单引号引起来 - 注意引号嵌套问题，如“‘’”或者‘“”’ - 在字符串中使用\\作为转义字符 \\\\&apos; ==&gt; &apos; \\\\&quot; ==&gt; &quot; \\n ==&gt; 换行 \\t ==&gt; 制表符 \\\\\\ ==&gt; \\ - 使用typeof运算符检查字符串时，会返回&quot;string&quot; Number 数值 - JS中所有的整数和浮点数 - JS中表示数字的最大值：Number.MAX_VALUE - JS中表示数字的最小（正数）值：Number.MIN_VALUE - 特殊的数字 Infinity 正无穷 -Infinity 负无穷 NaN 非法数字（Not A Number） - 其他进制的数字的表示： 0b 开头表示二进制，但是不是所有的浏览器都支持 0 开头表示八进制 0x 开头表示十六进制 - 使用typeOf检查一个Number类型的数据时，会返回&quot;number&quot;（包括NaN 和 Infinity） - JS中进行浮点运算，可能得到一个不精确的结果（计算时都是转换成二进制，而二进制不能精确表示浮点数，不能进行精确运算） Boolean 布尔值 - 布尔值主要用来进行逻辑判断，布尔值只有两个 - true 逻辑的真 - false 逻辑的假 - 使用typeof检查一个布尔值时，会返回&quot;boolean&quot; Null 空值 - 空值专门用来表示为空的对象，Null类型的值只有一个为null - **使用typeOf检查一个Null类型的值时会返回&quot;object&quot;** - 可以通过isNaN()函数来判断一个值是不是NaN，是则返回true，否则返回false Undefined 未定义 - 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined - 该类型的值只有一个为 undefined - 使用typeof检查一个Undefined类型的值时，会返回&quot;undefined&quot; 引用数据类型 - Object 对象 类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean 转换为String 方式一（强制类型转换）： - 调用被转换数据的toString()方法（返回转换的值） - 例子： var a = 123; a = a.toString(); - **注意：这个方法不适用于null和undefined** 由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）： - 调用String()函数（被转换数据作为参数） - 例子： var a = 123; a = String(a); - 原理：对于Number Boolea调用String函数则是调用他们的toString()方法来将其转换为字符串，而对于null，undefined，则是直接转换为字符串&quot;null&quot;，&quot;undefined&quot;。 方式三（隐式的类型转换）: - 为任意的数据类型 +&quot;&quot; - 例子： var a = true; a = a + &quot;&quot;; - 原理：和String()函数一样 - 转换为Number - 方式一（强制类型转换）： - 调用Number()函数 - 例子： var a = &quot;123&quot;; a = Number(a); - 转换的情况： 1.字符串 --&gt; 数字 - 如果字符串是一个合法的数字，则直接转换为对应的数字 - 如果字符串是一个非法的数字，则转换为NaN - 如果是一个空串(空字符串)或纯空格的字符串，则转换为0 2.布尔值 --&gt; 数字 - true转换为1 - false转换为0 3.空值 --&gt; 数字 - null转换为0 4.未定义 --&gt; 数字 - undefined 转换为NaN - 方式二（强制类型转换）： - 调用parseInt()或parseFloat() - 这两个函数专门用来将一个字符串转换为数字的 - parseInt() - 可以将一个字符串中的有效的整数位提取出来，并转换为Number - 例子： var a = &quot;123.456px&quot;; a = parseInt(a); //123 - 如果需要可以在parseInt()中指定一个第二个参数，来指定进制 - 例子： var a =“020”; //有的浏览器会认为这是一个八进制的数，有的浏览器会认为这是一个十进制的数 a = parseInt(a,10); //表示将其转换成十进制的数 - 对于非String的值会先将其转换成String再进行转换 - parseFloat() - 可以将一个字符串中的有效的整数位和小数位提取出来，并转换为Number - 例子： var a = &quot;123.456px&quot;; a = parseFloat(a); //123.456 - 方式三（隐式的类型转换）： - 使用一元的+来进行隐式的类型转换 - 例子： var a = &quot;123&quot;; a = +a; - 原理：和Number()函数一样 - 使用 -0 *1 /1 也可以j进行隐式的类型转换 - 原理：和Number()函数一样 - 转换为布尔值 - 方式一（强制类型转换）： - 使用Boolean()函数 - 例子： var s = &quot;false&quot;; s = Boolean(s); //true - 转换的情况 1.字符串 --&gt; 布尔 - 除了空串其余全是true 2.数值 --&gt; 布尔 - 除了0和NaN其余的全是true 3.null、undefined ---&gt; 布尔 - 都是false 4.对象 ---&gt; 布尔 - 都是true - 方式二（隐式类型转换）： - 为任意的数据类型做两次非运算（两次取反则布尔值不会变化），即可将其转换为布尔值 - 例子： var a = &quot;hello&quot;; a = !!a; //true3.8 运算符： 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作，然后返回一个结果 typeof运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 算数运算符（二元运算符） +对两个值进行加法运算并返回结果 -对两个值进行减法运算并返回结果 *对两个值进行乘法运算并返回结果 /对两个值进行除法运算并返回结果 %对两个值进行取余运算并返回结果（取模） 除了字符串以外，对其他非Number类型的值进行运算时，都会先转换为Number然后在做运算。（加，减，乘，除） 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。 任何值和字符串做加法，都会先转换为字符串，然后再拼串 任何值与NaN做运算最后都得NaN 一元运算符 一元运算符只需要一个操作数 一元的+ 就是正号，可以对一个数字进行符号位取正，也可以将一个非数字转换为数字 例子： var a = true; a = +a; // 1 一元的- 就是负号，可以对一个数字进行符号位取反，也可以将一个非数字转化成数字 例子： var a = 10; a = -a; // -10 自增 自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1（会直接改变原来的值，无需赋值） 不同的是获取到的++a和a++的值是不同的:a++的值是变量的原值（自增前的值）即先赋值后自增 ++a的值是变量的新值（自增后的值）即先自增后赋值 - 自减 - 自减可以使变量在原值的基础上自减1 - 自减使用 -- - 自减可以使用 前--（--a）后--(a--) - 无论是--a 还是 a--都会立即使原变量自减1（会直接改变原来的值，无需赋值） 不同的是获取到的--a和a--的值是不同的： a--的值是变量的原值（自减前的值） --a的值是变量的新值（自减后的值） 逻辑运算符 ! - 非运算可以对一个布尔值进行取反，true变false false变true 两次取反则不会有变化 - 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 &amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值（找false） 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值规则(类似于短路)： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值（找true） 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 赋值运算符 = 可以将符号右侧的值赋值给左侧变量 += a += 5 相当于 a = a+5 var str = “hello”; str += “world”;//helloworld -= a -= 5 相当于 a = a-5 *= a = 5 相当于 a = a5 /= a /= 5 相当于 a = a/5 %= a %= 5 相当于 a = a%5 关系运算符- 关系运算符用来比较两个值之间的大小关系的 &gt; &gt;= &lt; &lt;= - 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 - 如果比较的两个值是非数值，会将其转换为Number然后再比较。 - 如果比较的两个值都是字符串，此时会比较字符串中第一个字符的Unicode编码（相等的话依次比较）所以这样不能正确比较两个数字，我们一般选择先转型，使其中一方转换成数字，这样则都会转换成数字进行比较： 例子： console.log(&quot;123&quot; &gt; &quot;2&quot;);//false 比较了1和2的Unicode编码 console.log(&quot;123&quot; &gt; +&quot;2&quot;);//true 先转型再进行比较 相等运算符 == - 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false - 如果对不同的类型进行比较，会将其转换为相同的类型然后再比较 - 需要注意的是： - console.log(null == 0); // false - console.log(1 == &quot;1&quot;); // true - console.log(true == &quot;1&quot;); // true - console.log(undefined == null); // true undefined 衍生自null - console.log(NaN == NaN); // false NaN不与任何值相等，包括它本身 != - 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false - 不等也会做自动的类型转换。 === - 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，如果两个值的类型不同，则直接返回false - 需要注意的是： - console.log(1 ===&quot;1&quot;); // false - console.log(undefined === null); // false !== - 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 三元运算符：也叫条件运算符 ?: - 语法：条件表达式?语句1:语句2; - 执行流程： 1.先对条件表达式求值判断 2.如果判断结果为true，则执行语句1，并返回执行结果 3.如果判断结果为false，则执行语句2，并返回执行结果 ，运算符：使用，运算符来声明多个变量并赋值 运算符的优先级： - 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 - 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 - 优先级不需要记忆，如果不清楚的，使用()来改变优先级。 - 对象相关的优先级最高： . [] new 接着就是() 3.9 流程控制语句: 程序都是由一条条语句组成的 可以用{}为语句分组，用{}括起来的语句为代码块（但不会有隔离作用） 程序都是自上向下的顺序执行的， 通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 分类： 1.条件判断语句 2.条件分支语句 3.循环语句 条件判断语句 条件判断语句也称为if语句 语法一： if(条件表达式){ 语句... } 执行流程： if语句执行时，会先对条件表达式进行求值判断，如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句... }else{ 语句... } 执行流程： if…else语句执行时，会对条件表达式进行求值判断，如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else if(条件表达式){ 语句... }else{ 语句... } 执行流程 if…else if…else语句执行时，会自上至下依次对条件表达式进行求值判断，如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句 条件分支语句 switch语句 语法: switch(条件表达式){ case 表达式: 语句... break; case 表达式: 语句... break; case 表达式: 语句... break; default: 语句... break; } 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。使用break退出switch语句 如果所有的case判断结果都为false，则从default处开始执行代码。 循环语句(三步：初始化变量，设置条件表达式，更新表达式) 通过循环语句可以反复执行某些语句多次 while循环 语法： while(条件表达式){ 语句... } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环 语法: do{ 语句... }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 - for循环 - 语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句... } - 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② - 可嵌套 - 死循环 while(true){ //退出循环 //break； } for(;;){//省略了①②④ } break 和 continue（提升性能）： break 和 continue关键字可以用来退出switch或循环语句，退出离他最近的那个循环语句 可以为循环语句创建一个label，来标识当前的循环 label名称:循环语句 使用break语句时，可以在break后跟着设置的label名称，来指定退出的循环语句 break关键字，立即终止循环 continue关键字，跳过当次循环 测试性能： //在程序执行前，开启计时器 console.time(“计时器的名字”)可以用来开启一个计时器 它需要一个字符串作为参数，这个字符串将会作为计时器的标识 //在程序结束时，终止计时器 console.timeEnd()用来停止一个计时器，同样参数为计时器名字 3.10 对象（Object） 对象是JS中的引用数据类型 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性 对象的分类： 1.内建对象 由ES标准中定义的对象，在任何的ES的实现中都可以使用 比如：Math String Number Boolean Function Object…. 2.宿主对象 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 比如 BOM DOM 3.自定义对象 由开发人员自己创建的对象 使用typeof检查一个对象时，会返回object 创建对象(保存在一个变量中) 方式一： var obj = new Object(); 方式二： var obj = {}; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值;（推荐这种写法，不加引号是变量） 对象的属性名尽量按照标识符的要求去写。 属性值可以任意的数据类型。(包括对象) 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： delete 对象.属性名 delete 对象[“属性名”] 使用in运算符检查对象中是否含有指定属性 语法：”属性名” in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 使用对象字面量，在创建对象时直接向对象中添加属性 语法： var obj = { 属性名:属性值, 属性名:属性值, 属性名:属性值（最后一个就不要写逗号了） ... } 基本数据类型和引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型的数据，变量是直接保存的它的值。 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量保存的是对象的引用（内存地址）。 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值， 对于引用数据类型比较的是地址，地址相同才相同 3.11 函数（Function） 函数也是一个对象，也具有普通对象的功能 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码 使用typeof检查一个函数时会返回function 创建函数 函数声明 function 函数名([形参1,形参2…形参N]){ 语句... } 函数表达式 var 函数名 = function([形参1,形参2…形参N]){ //匿名函数即没有赋值 语句... }; 调用函数(后面加个括号一般就是在调用函数) 语法：函数对象([实参1,实参2…实参N]); 比如：alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 形参和实参 形参：形式参数（parameter） 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数（argument） 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值，可以是一个对象，也可以是一个函数（经常把匿名函数作为一个参数，即回调函数，会自己执行） 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined。 函数b作为参数进行传递给函数a时的括号问题： 当函数b加上括号时，通常会执行函数a本身。如果函数b有返回值，此时会得到函数b的返回值作为函数a的参数； 当函数b后不加括号时，其实质上是一个函数指针，用于找到函数b的位置并执行函数b。 因此，如果把函数作为参数进行值传递时，通常不需要加括号。但是如果是想要得到函数的返回值，就必须要加上括号。 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 立即执行函数： 函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行函数往往只会执行一次 语法：(function(){ //即调用匿名函数，在函数对象后面加上括号表示调用 })(); break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 方法（method） 可以将一个函数设置为一个对象的属性， 当一个对象的属性是一个函数时，我们称这个函数是该对象的方法。 对象.方法名(); 如：document.write(); 作用域（Scope） 作用域简单来说就是一个变量的作用范围。 在JS中作用域分成两种： 1.全局作用域 直接在script标签中编写的代码都运行在全局作用域中 全局作用域在打开页面时创建，在页面关闭时销毁。 全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口。 在全局作用域中创建的变量都会作为window对象的属性保存在全局作用域中创建的函数都会作为window对象的方法保存我们写代码的时候一般把window省略 在全局作用域中创建的变量和函数可以在页面的任意位置访问。在函数作用域中也可以访问到全局作用域的变量。 尽量不要在全局中创建变量 2.函数作用域 - 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。 - 函数作用域在函数执行时创建，在函数执行结束时销毁。 - 在函数作用域中创建的变量，不能在全局中访问。 - 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找， 如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，以此类推，最外一级是全局作用域（如果想要直接访问全局就在前面加个window） - 变量的声明提前（变量名的提升） - 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值（undefined）。 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前（会报错）。 - 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，（undefined） 如果没有使用var关键字声明变量，则该变量会变成全局变量 - 函数的声明提前 - 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性（只var了一个变量fun，即undefined，不会创建函数，会报错：undefined is not a function） - 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 this（上下文对象） 我们每次调用函数时，解析器（浏览器）都会将一个上下文对象作为隐含的参数传递进函数。 使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 this的不同的情况： 1.以方法的形式调用时，this就是调用方法的对象（如obj.sayName()，this是obj） 2.以函数的形式调用时，this是window（因为其实直接调用函数是省略写法，完整写法是window.fun(),所以也算调用了对象） 3.以构造函数的形式调用时，this就是新创建的对象 使用工厂方法创建对象 通过该方法可以大批量的创建对象 使用工厂方法创建的对象，使用的构造函数都是new Object所以创建的对象都是Object这个类型， 就导致我们无法区分出多种不同类型的对象 所以我们选择使用构造函数来创建对象 工厂方法例子： 1234567891011121314151617181920function createPerson(name , age ,gender)&#123; //创建一个新的对象 var obj = new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; //将新的对象返回 return obj;&#125;var sasuke = createPerson(\"佐助\",18,\"男\"); 构造函数（constructor） 构造函数是专门用来创建对象的函数 一个构造函数我们也可以称为一个类 通过一个构造函数创建的对象，我们称该对象是这个构造函数的实例 通过同一个构造函数创建的对象，我们称为一类对象 构造函数就是一个普通的函数，只是他的调用方式不同， 如果直接调用，它就是一个普通函数 如果使用new来调用，则它就是一个构造函数 例子： 12345678910function Person(name , age , gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;var chuya = new Person(\"中原中也\",18,\"男\"); 构造函数的执行流程： 1.创建一个新的对象 2.将新的对象作为函数的上下文对象（this），构造函数中可以使用this来引用新建的对象 3.执行函数中的代码 4.将新建的对象作为返回值返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性 for…in 语法： 12345for(var 变量 in 对象)&#123; console.log(变量); // 属性 console.log(对象[变量]); // 属性值 &#125;//对象中有几个属性， for...in语句的循环体就会执行几次。 原型（prototype） 创建一个函数以后，解析器都会默认在函数中添加一个属性prototype prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性指向该原型对象。 这个隐含的属性可以通过 对象.____proto____（左右各两个下划线）来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象,他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中,然后通过 对象.prototype.属性/方法 去访问。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到了，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object对象的原型的原型为null，（即object的原型，没有原型） 所以在object的原型依然没有找到则返回undefined （这样可以一层一层往外找称为原型链） hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性，有则返回true 语法：对象.hasOwnProperty(“属性名”) 与in的区别：使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true 调用函数的方法： call()与apply() 这两个方法都是函数对象的方法，需要通过函数对象来调用 通过两个方法可以直接调用函数fun(); fun.call(); fun.apply(); 这三个效果一致。 并且可以通过第一个实参来指定函数中thisfun.call(obj); fun.apply(obj);obj即指定的this，如果不指定就是window 不同的是call是直接传递函数的实参，而apply需要将实参封装到一个数组中传递fun.call(obj,a,b); fun.apply(obj,[a,b]); arguments 在调用函数时，浏览器每次都会传递进两个隐含的参数：1.函数的上下文对象 this 2.封装实参的对象 arguments - arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度 - 在调用函数时，我们所传递的实参都会在arguments中保存 - arguments.length可以用来获取实参的长度 - 我们即使不定义形参，也可以通过arguments来使用实参 arguments[0] 表示第一个实参 arguments[1] 表示第二个实参 ... - arguments中有一个属性callee表示当前执行的函数对象 thisthis是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window2.以方法的形式调用时，this是调用方法的对象3.以构造函数的形式调用时，this是新建的那个对象4.使用call和apply调用时，this是指定的那个对象5.在全局作用域中this代表window 3.12 数组（Array） 数组也是一个对象，是一个用来存储数据的对象 和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素（普通对象使用字符串作为属性名） 索引指由0开始的整数 typeof为object 数组的操作： 创建数组 var arr = new Array(); var arr = [];//使用字面量 向数组中添加元素 语法: 数组对象[索引] = 值; arr[0] = 123; arr[1] = “hello”; … 创建数组时直接添加元素 语法： 方式一：var arr = [元素1,元素2….元素N];（建议使用） 例子： var arr = [123,”hello”,true,null,对象，函数，数组…]; //数组元素可以是任意类型 。 如果是放数组则是二维数组。 方式二：var arr = new Array(元素1,元素2….元素N);//将要添加的元素作为构造函数的参数 注意当只有一个元素的时候，方式一表示只有这个元素，方式二表示长度。 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度： 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度- 如果修改后的length大于原长度，则多出的部分会空出来 - 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值;（length 比最后的索引+1） 数组的方法 push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度(返回值) 语法：数组.push(元素1,元素2,元素N) pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的前边添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的前边的一个元素，并返回被删除的元素 注意操作前面的元素会影响后边元素的索引 slice() 可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数（倒数） splice() 可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 （要考虑到补位改变了索引的问题） 参数： 1.删除开始位置的索引 2.删除的个数 3.第三个及以后，都是替换的元素，这些元素将会插入到开始位置索引的前边 reverse() 可以用来反转一个数组，它会对原数组产生影响 concat() 可以连接两个或多个数组（也可以是元素），新的数组或元素作为参数，用逗号隔开。它不会影响原数组，而是新数组作为返回值返回 join() 可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用逗号 sort() 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序 会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： 1234567891011function(a,b)&#123; //回调函数中需要定义两个形参 //升序排列 return a-b; //降序排列 return b-a; &#125; filter() - 检测数组元素，并返回符合条件的所有元素组成的新数组。 - filter() 不会对空数组进行检测，也不会改变原始数组。 - 语法：array.filter(function(currentValue,index,arr), thisValue) - 解析： function：必须。函数，数组中的每个元素都会执行这个函数 currentValue：必须。当前元素的值 index：可选。当前元素的索引值 arr：可选。当前元素属于的数组对象 thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。如果省略了 thisValue ，&quot;this&quot; 的值为 &quot;undefined&quot; - 示例：12345678//返回数组 ages 中所有元素都大于 18 的元素:var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;alert(ages.filter(checkAdult));//输出结果为:32,33,40 遍历数组 遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组： for(var i=0 ; i&lt;数组.length ; i++){ //数组[i] } 使用forEach()方法来遍历数组（不兼容IE8及以下） 数组.forEach(function(value , index , obj){ }); //像这种由我们创建但不由我们调用而是浏览器调用的函数我们称为回调函数。 forEach()方法需要一个回调函数作为参数， 数组中有几个元素，回调函数就会被调用几次， 每次调用时，都会将遍历到的信息以实参的形式传递进来， 我们可以定义形参来获取这些信息。 浏览器会在回调函数中传递三个参数： value:正在遍历的元素 index:正在遍历元素的索引 obj:被遍历数组对象 检查是否是数组： Array.isArray();参数即被检查内容，返回true即是，返回false即否 3.13 Date（函数对象） 日期的对象，在JS中通过Date对象来表示一个时间 创建对象 创建一个当前的时间对象 var d = new Date();//函数对象 创建一个指定的时间对象 var d = new Date(“月/日/年 时:分:秒”); 方法： getDate() - 当前日期对象是几日（1-31） getDay() - 返回当前日期对象时周几（0-6） - 0 周日 - 1 周一 getMonth() - 返回当前日期对象的月份（0-11） - 0 一月 1 二月... getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() - 返回当前日期对象的时间戳(时间差) - 时间戳，指的是从格林威治标准时间1970年1月1日 0时0分0秒（跟北京时间有8小时时间差），到现在时间的毫秒数的差值 （一秒 = 1000 毫秒） 计算机底层保存时间都是以时间戳的形式保存的。 - 转换：var time = x.getTime(); time/1000/60//60/24/365(算出相应的秒，分，时，天，年) Date.now() - 可以获取当前代码执行时的时间戳 时间戳也可以用来测试代码性能 3.14 Math（普通对象）- Math属于一个工具类，它不需要我们创建对象，它里边封装了数学运算相关的属性（常量，大写的属性一般是常量）和方法 - 方法： Math.PI - 常量，圆周率 Math.abs() - 绝对值运算 absolute Math.ceil() - 向上取整 Math.floor() - 向下取整 Math.round() - 四舍五入取整 Math.random() - 生成一个0-1之间的随机数(不包括0和1) - 生成一个x-y之间的随机整数（包括x和y,因为四舍五入的关系） Math.round(Math.random()*(y-x)+x); Math.pow(x,y) - 求x的y次幂 Math.sqrt() - 对一个数进行开方 Math.max() - 求多个数中最大值 Math.min() - 求多个数中的最小值3.16 包装类 在JS中为我们提供了三个包装类(构造函数)： String() Boolean() Number() 通过这三个包装类可以创建基本数据类型的对象 例子： 1234var num = new Number(2);//将基本数据类型字符串转换成String对象var str = new String(\"hello\");var bool = new Boolean(true); 但是在实际应用中不会用到基本数据类型对象。而是计算机底层自己用的。如下： 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，（方法和属性只能添加给对象，不能添加给基本数据类型）操作完成以后再将这个临时对象进行销毁。 3.16 String对象的属性和方法：当我们调用String对象的属性和方法时，因为解析器会自动将基本数据类型字符串临时转换成String对象，所以字符串也可以直接使用这些属性和方法。 属性：length（获取字符串的长度） 在底层字符串是以字符数组的形式保存的（将字符串拆分成一个个字符）。 方法：（不会影响本身，是返回一个值） 有些方法和数组是类似的。 concat() 连接字符串，不如+好使 charAt() 根据索引获取指定的字符 charCodeAt() 根据索引获取指定的字符编码（Unicode编码） String.fromCharCode() 根据字符编码获取字符 indexOf()和lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找 slice() 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原字符串 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置（不包括结束） 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数（倒数） substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 - substring() - 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置 - toLowerCase() - 将字符串转换为小写并返回 - toUpperCase() - 将字符串转换为大写并返回 - split() - 可以根据指定内容将一个字符串拆分为一个数组 - 参数： - 需要一个字符串作为参数，将会根据字符串去拆分数组 - 如果传的是空串，则每个字符用逗号隔开 - 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 - 正则表达式没有设置全局g也会全部拆分 - match() - 可以将字符串中和正则表达式匹配的内容提取出来 - 参数： - 正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来,且封装到一个数组中返回 - 默认情况下match只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 - replace() - 可以将字符串中指定内容替换为新的内容 - 参数： - 第一个：被替换的内容，可以是一个正则表达式 - 第二个：替换的新内容，如果设置为空串则相当于删除 - 默认只会替换第一个，也是可以设置全局通配 - search() - 可以根据正则表达式去字符串中查找指定的内容 - 参数： 正则表达式，将会根据该表达式查询内容，并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1。 - serach()只会查找第一个，即使设置全局匹配也没用 - 与match（）区别：match（）返回的是数组，serach（）返回的是索引 - trim() - 不会改变原始字符串。 - 返回值：返回移除头尾空格的字符串。3.17 正则表达式 正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则， 也可以将一个字符串中符合规则的内容提取出来。 Regular Expression，在代码中常简写为regex、regexp或RE 创建正则表达式对象： var reg = new RegExp(“正则表达式”,”匹配模式”); var reg = /正则表达式/匹配模式;（字面量） 直接写//里面是表示含有，^ 表示开始，$ 表示结束，这两个写上则表示需完全符合正则表达式规则。 语法： 匹配模式： i:忽略大小写 g:全局匹配模式（检测到了还是会继续检测，即全部检测一遍） 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求。 正则语法 : | 或 [ ] 或 [^ ] 除了 [a-z] 任意小写字母 [A-Z] 任意大写字母 [A-z] 任意字母 [0-9] 任意数字 - 量词（设置出现的次数，只对其前边一个内容起作用，想要对多个内容起作用可以用括号表示整体） {n} 正好n次 {m,n} m-n次 {m,} 至少m次 + 至少1次 相当于{1,} ? 0次或1次 相当于{0,1} * 0次或多次 相当于{0,} 可有可无的意思 - 转义字符 \\ 在正则表达式中使用\\作为转义字符 （注意在使用构造函数创建正则表达式的时候，因为是写在字符串中，而\\在字符串中也表示转义字符，想要表示\\需要写\\\\） \\\\. 表示. \\\\\\ 表示\\ . 表示任意字符 \\w - 相当于[A-z0-9_] 任意字母，数字，下划线 \\W - 相当于[^A-z0-9_] \\d - 任意数字 \\D - 除了数字 \\s - 空格 \\S - 除了空格 \\b - 单词边界 如/\\bchild\\b/ 检查是否含有单词child - 举例：children 和 child 的区别 \\B - 除了单词边界 方法： test() - 可以用来检查一个字符串是否符合正则表达式 - 如果符合返回true，否则返回false","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"编码","slug":"编码","date":"2020-04-22T07:01:17.000Z","updated":"2020-04-22T07:37:01.936Z","comments":true,"path":"2020/04/22/编码/","link":"","permalink":"http://yoursite.com/2020/04/22/编码/","excerpt":"编码介绍：","text":"编码介绍： 乱码：编码和解码所采用的字符集不同 （计算机是二进制编码，只识别0,1） 字符集：编码和解码（进制的转换）所采用的规则 常见的字符集：ASCII(美国),ISO-8859-1(欧洲),GBK（中国）,GB2312(中国系统默认编码),UTF-8(通用，国际性),ANSI(自动以系统的默认编码来保存文件) Unicode包括utf-8等 在中文系统的浏览器中，默认使用GB2312进行解码 输入Unicode编码输出相应字符： JS写法：\\u四位编码（十六进制）例子：console.log(“\\u2620”); HTML写法：&amp;#编码; （十进制） 需要将Unicode编码转换成十进制数例子：&amp;#9760; &#9760;","categories":[],"tags":[]},{"title":"浏览器兼容性","slug":"浏览器兼容性","date":"2020-04-22T06:57:21.000Z","updated":"2020-04-22T06:58:08.395Z","comments":true,"path":"2020/04/22/浏览器兼容性/","link":"","permalink":"http://yoursite.com/2020/04/22/浏览器兼容性/","excerpt":"浏览器兼容性：","text":"浏览器兼容性： -webkit- Chrome /krəʊm/ iOS Safari [səˈfɑːri] Android Browser [ˈændrɔɪd] Samsung Internet（三星互联网）[ˈsæmsʌŋ] UC Browser for Android QQ Browser -moz- Firefox -ms- Internet Explorer （Mobile） [ɪkˈsplɔːrə(r)] 兼容IE插件：CSS3PIE 用法参考网址 -o- Opera [ˈɒprə] 欧朋 写法：在这些前缀的后面加上属性，没有前缀的原始写法一般放在最后。 IE可下载IETester进行兼容测试（仅供参考）","categories":[],"tags":[]},{"title":"前端基础","slug":"前端基础","date":"2020-04-22T06:55:37.000Z","updated":"2020-04-22T06:56:41.883Z","comments":true,"path":"2020/04/22/前端基础/","link":"","permalink":"http://yoursite.com/2020/04/22/前端基础/","excerpt":"前端基础：","text":"前端基础： 1. 软件架构：1.1 C/S:客户端（client）/服务器（server） 服务器：处理软件的业务逻辑 特点：需要安装，通过客户端来使用软件，客户端和服务器需同时更新，不能跨平台（系统），通信采用自有协议（相对安全，协议相对于密码本） 1.2 B/S:浏览器（browser）/服务器（server） 本质上也是C/S，只是它的客户端是浏览器 特点：不需要安装，通过浏览器访问网页的形式来使用软件，服务器更新则客户端更新，能跨平台（系统），通信采用HTTP协议（相对不安全）,现在更多的是采用HTTPS协议(相对安全) 2. 软件开发流程： photoshop: 根据需求设计网页 HTML: 静态网页 后台语言：动态网页 3. 网页构成：根据W3C（万维网联盟组织，规范HTML,CSS,DOM,HTTP,XML等标准）标准[WHATWG组织，规范HTML5标准]，一个网页分为三部分：结构(HTML)、表现(CSS,样式)和行为(JavaScript，响应用户操作)。一个优化的网页需要实现三者分离。 不用汉字命名各种文件，否则路径可能出问题。 4. 开发工具(IDE)：记事本，notepad++，sublimeHbuilder: 测试的时候会自动发送到本地服务器，尽力模拟真实开发环境 输入样式，右侧会提示浏览器兼容性vscode:webstorm:https://www.jianshu.com/p/4ce97b360c13","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"less学习笔记","slug":"less学习笔记","date":"2020-04-22T06:52:28.000Z","updated":"2020-04-22T06:53:58.725Z","comments":true,"path":"2020/04/22/less学习笔记/","link":"","permalink":"http://yoursite.com/2020/04/22/less学习笔记/","excerpt":"less：参考网址css预处理器之一。","text":"less：参考网址css预处理器之一。 扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。 使用less： 引入less.js文件（官网下载或者CDN）123//浏览器端不用编译，可以直接使用：&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt;&lt;script src=\"less.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 需要注意：link标签的rel属性修改为stylesheet/less。 在命令行使用npm安装(1) 全局安装:npm install less -g(2) 项目目录安装:npm i less –save-dev 如果你在本地环境，可以使用第一种方式，非常简单；但在生产环境中，性能非常重要，最好使用第二种方式。 变量值变量12345678/* Less */@color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap &#123; color: @color; width: @width; &#125; 12345/* 生成后的 CSS */ #wrap &#123; color: #999; width: 50%; &#125; 以 @ 开头 定义变量，并且使用时 直接 键入 @名称。在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。 选择器变量让 选择器 变成 动态 12345678910111213/* Less */ @mySelector: #wrap; @Wrap: wrap; @&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%; &#125; .@&#123;Wrap&#125;&#123; color:#ccc; &#125; #@&#123;Wrap&#125;&#123; color:#666; &#125; 1234567891011/* 生成的 CSS */ #wrap&#123; color: #999; width: 50%; &#125; .wrap&#123; color:#ccc; &#125; #wrap&#123; color:#666; &#125; 属性变量可减少代码书写量 123456/* Less */ @borderStyle: border-style; @Soild:solid; #wrap&#123; @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹 &#125; 1234/* 生成的 CSS */ #wrap&#123; border-style:solid; &#125; url 变量项目结构改变时，修改其变量即可。 12345/* Less */ @images: \"../img\";//需要加引号 body &#123; background: url(\"@&#123;images&#125;/dog.png\");//变量名 必须使用大括号包裹 &#125; 1234/* 生成的 CSS */ body &#123; background: url(\"../img/dog.png\"); &#125; 声明变量（有点类似于 下面的 混合方法） 结构: @name: { 属性: 值 ;}; 使用：@name();123456789/* Less */ @Rules:&#123; width: 200px; height: 200px; border: solid 1px red; &#125;; #con&#123; @Rules(); &#125; 123456/* 生成的 CSS */ #con&#123; width: 200px; height: 200px; border: solid 1px red; &#125; 变量运算 加减法时 以第一个数据的单位为基准 乘除法时 注意单位一定要统一12345678910/* Less */ @width:300px; @color:#222; #wrap&#123; width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111; &#125; 12345678/* 生成的 CSS */ #wrap&#123; width:280px; height:200px; margin:1400px; color:#444; background-color:#333; &#125; 变量作用域一句话理解就是：就近原则，不要跟我提闭包。 1234567/* Less */ @var: @a; @a: 100%; #wrap &#123; width: @var; @a: 9%; &#125; 1234/* 生成的 CSS */ #wrap &#123; width: 9%; &#125; 用变量去定义变量123456/* Less */ @fnord: \"I am fnord.\"; @var: \"fnord\"; #wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord; &#125; 1234/* 生成的 CSS */ #wrap::after&#123; content: \"I am fnord.\"; &#125; 嵌套css分组和嵌套： 分组：将一样的写到一组举例： 123h1,h2,p &#123;//分组选择器 color:green;&#125; 嵌套： p{ }: 为所有 p 元素指定一个样式。.marked{ }: 为所有 class=”marked” 的元素指定一个样式。.marked p{ }: 为所有 class=”marked” 元素内的 p 元素指定一个样式。（后代元素）p.marked{ }: 为所有 class=”marked” 的 p 元素指定一个样式。（交集） &amp;&amp; ：代表的上一层（父元素）选择器的名字//理解方式：直接把 &amp; 替换成 上一层（父元素）选择器的名字（不存在空格） 123456789101112131415/* Less */ #header&#123; &amp;:after&#123; content:\"Less is more!\"; &#125; .title&#123; font-weight:bold; &#125; &amp;.title&#123; font-weight:bold; &#125; &amp;_content&#123; margin:20px; &#125; &#125; 12345678910111213/* 生成的 CSS */ #header::after&#123; content:\"Less is more!\"; &#125; #header .title&#123; font-weight:bold; &#125; #header.title&#123; font-weight:bold; &#125; #header_content&#123; margin:20px; &#125; 媒体查询css3媒体查询：媒体查询可用于检测很多事情。例如： viewport(视窗) 的宽度与高度 设备的宽度与高度 朝向 (智能手机横屏，竖屏) 。 分辨率 目前很多针对苹果手机，Android 手机，平板等设备都会使用到多媒体查询。 多媒体查询语法：多媒体查询由多种媒体组成，可以包含一个或多个表达式，表达式根据条件是否成立返回 true 或 false。如果指定的多媒体类型匹配设备类型则查询结果返回 true，文档会在匹配的设备上显示指定样式效果。 123@media not|only mediatype and (expressions) &#123;CSS 代码...;&#125; not: not是用来排除掉某些特定的设备的，比如 @media not print（非打印设备）。 only: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件。 也可以在不同的媒体上使用不同的样式文件： 1&lt;link rel=\"stylesheet\" media=\"\" href=\"xxx.css\"&gt; CSS3 多媒体类型（mediatype） 值 描述 all 用于所有多媒体类型设备 print 用于打印机 screen 用于电脑屏幕，平板，智能手机等 speech 用于屏幕阅读器 css 使用 媒体查询，都要把一个元素 分开写。Less 提供了一个十分便捷的方式。 12345678910111213/* Less */ #main&#123; //something... @media screen&#123; @media (max-width:768px)&#123; width:100px; &#125; &#125; @media tv &#123; width:2000px; &#125; &#125; 1234567891011/* 生成的 CSS */ @media screen and (maxwidth:768px)&#123; #main&#123; width:100px; &#125; &#125; @media tv&#123; #main&#123; width:2000px; &#125; &#125; 唯一的缺点就是 每一个元素都会编译出自己 @media 声明，并不会合并。 混合方法无参数方法方法 犹如 声明的集合，使用时 直接键入名称即可。 123456789/* Less */ .card &#123; // 等价于 .card() background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card;//等价于.card(); &#125; 123456/* 生成的 CSS */ #wrap&#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; 其中 .card 与 .card() 是等价的。所以也可以这么写（建议写法）： 123456.card()&#123; //something... &#125; #wrap&#123; .card(); &#125; 要点：. 与 # 皆可作为 方法前缀。方法后写不写（）看个人习惯。 默认参数方法Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。@arguments 犹如 JS 中的 arguments 指代的是 全部参数。传的参数中 必须带着单位。 1234567891011121314/* Less */ .border(@a:10px,@b:50px,@c:30px,@color:#000)&#123; border:solid 1px @color; box-shadow: @arguments;//指代的是 全部参数 &#125; #main&#123; .border(0px,5px,30px,red);//必须带着单位 &#125; #wrap&#123; .border(0px); &#125; #content&#123; .border;//等价于 .border() &#125; 12345678910111213/* 生成的 CSS */ #main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red; &#125; #wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000; &#125; #content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000; &#125; 方法的匹配模式与 面向对象中的多态 很相似。 面向对象的多态：多态字面意思多种状态，指的是不同的对象按照统一接口执行时，产生多种不同的结果。即同一个实现接口，使用不同的实例而执行不同的操作。思想：实际上是把“做什么”和“谁去做“分开。具体：提供统一接口，让不同实例使用这一接口调用不同的函数。例子：主人发出一个”叫”的命令，狗发出汪汪的叫声，猫发出喵喵的叫声 常规非多态代码 1234567891011121314//非多态代码 function makeSound(animal) &#123; if(animal instanceof Dog) &#123; console.log(\"汪汪汪\") &#125; else if (animal instanceof Cat) &#123; console.log(\"喵喵\") &#125; &#125; function Dog() &#123;&#125; function Cat() &#123;&#125; makeSound(new Dog())makeSound(new Cat()) 多态代码12345678910111213141516function makeSound2(animal) &#123; animal.sound()&#125; function Dog2()&#123;&#125;Dog2.prototype.sound = function() &#123; console.log(\"汪汪汪\")&#125; function Cat2()&#123;&#125;Cat2.prototype.sound =function() &#123; console.log(\"喵喵喵\")&#125; makeSound2(new Dog2())makeSound2(new Cat2()) 比较而言，多态代码比非多态代码要臃肿，但是多态代码比非多态代码要好扩展和维护。 123456789101112131415161718192021/* Less */ .triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ; &#125; .triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ; &#125; .triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ; &#125; .triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color; &#125; .triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width; &#125; #main&#123; .triangle(left, 50px, #999) &#125; 123456/* 生成的 CSS */ #main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; &#125; 要点 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。???方法的命名空间让方法更加规范。命名空间：命名空间可以比喻为文件夹，主要是为了让我们找到文件和识别文件。当我们设置了相同的文件名字，可以将它们放入不同的文件夹中，这样就可以避免文件的冲突。 我们使用namespace来表示名字空间。所谓namespace，是指标识符的各种可见范围。 命名空间是用来组织和重用代码的。 12345678910111213141516171819202122232425/* Less */ #card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 width: @w; &#125; &#125; &#125; #wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 &#125; #main&#123; #card .d(); &#125; #con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card &#125; 1234567891011/* 生成的 CSS */ #wrap&#123; height:100px; width:300px; &#125; #main&#123; width:300px; &#125; #con&#123; width:20px; &#125; 要点 在 CSS 中&gt;选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命名空间时，如使用&gt;选择器，父元素不能加 括号。 不得单独使用命名空间的方法, 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法方法的条件筛选Less 没有 if else，可是它有 when1234567891011121314151617181920212223/* Less */ #card&#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border:@style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222)&#123; background:@color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123; font-size: @size; &#125; &#125; #main&#123; #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px); &#125; 123456/* 生成后的 CSS */ #main&#123; border:solid #999 200px; background:#111; font-size:40px; &#125; 要点 比较运算有： &gt; &gt;= = =&lt; &lt;。（注意小于或等于与平时写法不一致） 除去关键字 true 以外的值都被视为 false 数量不定的参数如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。 1234567891011/* Less */ .boxShadow(...)&#123; box-shadow: @arguments; &#125; .textShadow(@a,...)&#123; text-shadow: @arguments; &#125; #main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red); &#125; 12345/* 生成后的 CSS */ #main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red; &#125; 方法使用!important使用方法 非常简单，在方法名后 加上关键字即可。 12345678/* Less */ .border&#123; border: solid 1px red; margin: 50px; &#125; #main&#123; .border() !important; &#125; 12345/* 生成后的 CSS */ #main &#123; border: solid 1px red !important; margin: 50px !important; &#125; 循环方法Less 并没有提供 for 循环功能，但可以使用递归去实现。模拟了生成栅格系统。 栅格系统：栅格系统用于通过一系列row与列colum的组合来创建页面布局，HTML内容就放于这些创建好的布局中。 123456789/* Less */ .generate-columns(4); .generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1)); &#125; 12345678910111213/* 生成后的 CSS */ .column-1 &#123; width: 25%; &#125; .column-2 &#123; width: 50%; &#125; .column-3 &#123; width: 75%; &#125; .column-4 &#123; width: 100%; &#125; 属性拼接方法+_ 代表的是 空格； 代表的是 逗号。 逗号：12345678/* Less */ .boxShadow() &#123; box-shadow+: inset 0 0 10px #555; &#125; .main &#123; .boxShadow(); box-shadow+: 0 0 20px black; &#125; 1234/* 生成后的 CSS */ .main &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black; &#125; 空格: 12345678/* Less */ .Animation() &#123; transform+_: scale(2); &#125; .main &#123; .Animation(); transform+_: rotate(15deg); &#125; 1234/* 生成的 CSS */ .main &#123; transform: scale(2) rotate(15deg); &#125; 继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。 extend 关键字的使用12345678910111213/* Less */ .animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125; &#125; #main&#123; &amp;:extend(.animation); &#125; #con&#123; &amp;:extend(.animation .hide); &#125; 1234567/* 生成后的 CSS */ .animation,#main&#123; transition: all .3s ease-out; &#125; .animation .hide , #con&#123; transform:scale(0); &#125; all 全局搜索匹配使用选择器匹配到的 全部声明。 12345678910/* Less */ #main&#123; width: 200px; &#125; #main &#123; &amp;:after &#123; content:\"Less is good!\"; &#125; &#125; #wrap:extend(#main all) &#123;&#125; 1234567/* 生成的 CSS */ #main,#wrap&#123; width: 200px; &#125; #main:after, #wrap:after &#123; content: \"Less is good!\"; &#125; 减少代码的重复性从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。方法示例 与上面的 extend 进行对比： 12345678910111213/* Less */ .Method&#123; width: 200px; &amp;:after &#123; content:\"Less is good!\"; &#125; &#125; #main&#123; .Method; &#125; #wrap&#123; .Method; &#125; 12345678910111213/* 生成的 CSS */ #main&#123; width: 200px; &amp;:after&#123; content:\"Less is good!\"; &#125; &#125; #wrap&#123; width: 200px; &amp;:after&#123; content:\"Less is good!\"; &#125; &#125; ​","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"CSS学习笔记2","slug":"CSS学习笔记2","date":"2020-04-22T06:36:31.000Z","updated":"2020-04-22T06:38:53.111Z","comments":true,"path":"2020/04/22/CSS学习笔记2/","link":"","permalink":"http://yoursite.com/2020/04/22/CSS学习笔记2/","excerpt":"1. css简介","text":"1. css简介 层叠样式表（Cascading Style Sheets）网页是多层次的，层次高的会覆盖层次低的。 2. 样式分类：2.1 行内样式直接写到元素的style属性中，不推荐使用 2.2 内部样式写到head中的style标签内： 123456&lt;style type=\"text/css\"&gt; 选择器&#123; 属性名：属性值； &#125; /* 大括号以及其内容称之为声明块，声明块中的每个声明以名值对的结构出现，用 ; 隔开 */&lt;/style&gt; 2.3 外部样式写到外部css文件中，在head中通过link标签引用： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"路径，如style.css\"&gt; 实现结构和表现分离，通过link标签引入，利用浏览器的缓存（css的复用，其中一个引用了该css的网页加载的时候进行缓存，其他网页就不需要加载了）加快访问速度，提高用户体验，推荐使用。 3. css语法：3.1 css注释：1/* 注释*/ 3.2 选择器：3.2.1 元素选择器：语法：标签名{} 3.2.2 id选择器（唯一）：通过元素的id属性值选中唯一一个元素语法：#id属性值{} 3.2.3 类选择器（重复）：通过元素的class属性值选中一组元素，一个元素可以有多个class属性值，用空格隔开。语法：.class属性值{} 3.2.4 并集选择器（满足其一）：给多个选择器设置样式，用逗号隔开。语法：选择器1，选择器2，选择器n{} 3.2.5 通配选择器（所有）：选中页面所有元素。语法：*{} 3.2.6 复合选择器（交集）：同时满足多个选择器应用样式。语法：选择器1选择器2选择器n{} （选择器紧挨在一起） 3.2.7 后代元素选择器：选择指定祖先元素的后代元素，用空格隔开。语法：祖先元素 后代元素{}后代全选：祖先元素 *{} 3.2.8 子元素选择器：选择指定父元素的子元素，用&gt;隔开。语法：父元素&gt;子元素{} IE6及以下不兼容子元素选择器 3.2.9 伪类选择器（元素状态）：a:link(正常) a:visited访问过的() a:hover(移入状态) a:active(激活状态) 这四个优先级是一样的，为了不产生冲突，应按上面的顺序编写，否则可能出现样式失效。 hover与active也可以应用于其他元素，但IE6不兼容超链接以外的应用。 :focus(获取焦点)::selection(文字的选中状态) 火狐不兼容，应该这么写：-moz- selection浏览器是通过历史记录来判断是否访问过由于涉及到隐私问题，visited只能设置字体颜色 冒号前面内容应该是本身：:first-child 第一个子元素:last-child 最后一个子元素:only-child 那种仅有一个子元素:nth-child(参数) 任意位置的子元素even或者2n表示偶数，odd或者2n+1表示奇数（如果是想从第三个才开始计算那就2n+3）:nth-last-child(参数) 倒数 :first-of-type 第一个子元素:last-of-type 最后一个子元素:nth-of-type(参数) 任意位置的子元素 两者区别就是child是在所有元素中排列，而type是在当前类型的子元素中排列如果只有一个元素既是第一个也是最后一个 否定伪类：从选中的元素中剔除某些元素:not(选择器) 括号内为剔除内容 :empty 没有子元素 3.2.10 伪元素选择器（元素位置）：:first-letter（首字母） :first-line（第一行）:before（元素前面的部分） :after（元素后面的部分） 一般与content配合使用，content设置before与after的内容 3.2.11 属性选择器（属性名或值）：语法：[属性名] 或者 [属性名=”属性值”] [属性名^=”属性值”] 开头；[属性名$=”属性值”] 结尾 [属性名*=”属性值”] 包含 3.2.12 兄弟选择器：+ ： 选中元素后紧挨着的元素~ ： 选中元素后所有的元素 3.3 样式继承：后代元素会继承祖先元素的样式。有一些样式不能被继承。比如背景相关，边框相关，定位相关等的样式不能被继承。ps:视觉效果背景颜色会被继承，因为背景颜色的默认值是透明 3.4 选择器优先级：优先级高的优先显示。优先级规则：内联样式：1000id选择器：100类和伪类：10元素选择器：1通配选择器：0继承样式：没有优先级 当选择器包含多个时，需要将各个选择器的优先级进行相加再进行比较。（交集选择器）并集选择器需要单独计算，即互不影响。 如果优先级一样，则选择靠后的选择器。 在样式后面添加 ！important 则成为最高级的样式。避免使用。 123p&#123; color:red !important;&#125; 练习：cssDiner游戏 3.5 单位：3.5.1 长度单位： px：像素，使用最多（屏幕实际上就是由像素点构成的，不同显示器一个像素的大小不同，显示效果越好越清晰则像素点越小，一般手机的像素点是电脑的1/4，手机上的浏览器会自动将像素x4，以实现字体不会过小） %：百分比，通过父元素的样式来计算该值。（自适应页面） em：通过当前元素的字体大小来计算该值。1em = 1 font-size 设置字体相关的样式：如缩进：text-indent：2em; 3.5.2 颜色单位： 英语单词直接表示对应颜色 RGB值（red，green，blue三元色浓度）表示颜色（取值范围0255或者0%100%,0表示没有，255值最大，对应100%） 使用截图工具可看到rgb值 十六进制数：#十六进制（三组两位表示一个颜色，每一组分别对应红、绿，蓝，取值范围00~ff，两两重复的可以简写，00对应RGB的0，ff对应RGB的255） 都没有即是黑色，都最大即是白色 screen color picker 屏幕取色器，可看到十六进制值 3.6 字体、文本样式： color：颜色 font-size：字体大小，浏览器默认大小是16px（事实上font-size设置的并不是字体本身大小，而是字体所处的方框的大小，一般字体会比方框小一些，有的时候也会大一些，不同字体显示效果不同） font-fmaily：字体类型，可支持多个字体，用逗号隔开（浏览器优先选择写在前边的，依次往后选择，如果没有或者浏览器不兼容则采用浏览器默认字体，不同浏览器默认字体不同）是否能够显示取决于计算机是否存在该字体（开发中不建议使用不常见字体，如要使用可以采用图片形式或者网络引用） 字体分类： 在网页中将字体分为5大类，常见两类：serif（衬线字体，比如宋体）sans-serif（非衬线字体，比如微软雅黑）用法：当将字体设置为其中一大类的时候，浏览器会自动选择该类的其中一种字体应用样式，一般写在font-fmaily的最后。 font-style: 字体样式，normal（默认值，正常）italic（斜体） oblique（斜的）两个倾斜效果一致，一般使用italic。 font-weight：字体粗细，normal（默认值，正常） bold（粗体）还有其他值可以设置，但一般我们只设置这两个值，因为计算机没有设置那么多级别的粗细可以选择。 font-variant：normal（默认值，正常） small-caps（小型大写字母） 行间距：通过设置行高line-height来设置行间距。行间距 = 行高 - 字体大小行高即页面上线与线之间的距离，字体在行高中垂直居中显示。line-height 可以直接是px大小，也可以直接设置为百分比（相对于字体大小，100%即是字体大小），更常用的是直接设置一个数字（相对于字体大小，1即是字体大小） 垂直居中：由于字体默认在行高中垂直居中显示，所以对于单行文本来说，设置行高和父元素高度一致的话，单行文本则会在父元素中垂直居中。 font：small-caps bold italic 30px/50px “微软雅黑”； 简写：前三个无所谓顺序，且可写可不写（不写则是默认值），字体大小必须是倒数第二个，字体大小后面加上斜杆以及行高，行高可以不写，不写则是默认值，字体类型必须是最后一个（字体大小和字体类型必须写）。不同的值用空格隔开。 使用简写性能更好。 当设置字体样式时，font最好写在最上方，因为font没有指定其他值，则会设置成默认值将其他已设置的值覆盖。 text-transform：设置字母大小写可选值：none（默认）| capitalize（以大写字母开头）| uppercase（大写字母）| lowercase（小写字母） text-decoration：设置文本修饰可选值：none（默认值），underline（下划线），overline（上划线），line-through（删除线） 去除超链接的下划线：text-decoration：none letter-spacing：字符间距 word-spacing：单词间距 text-align：文本对齐可选值：left（左对齐）right（右对齐）center（居中）justify（两端对齐）实现两端对齐也可以：通过调整空格之间的距离 text-indent：首行缩进（一般设置单位为em，即字体单位；设置为负值可隐藏文字） 4. 网页布局：4.1 盒子（box）模型（框模型）：每个元素都是一个盒子。通过对盒子的摆放来设置网页布局。盒子可见框大小=内容区大小+边框+内边距（元素的背景会延伸到内边距，但内边距不能放内容） 4.1.1 块元素： 设置内容区大小：width height border：设置边框，三个样式缺一不可（但一般浏览器有默认值） border： border-width（宽度） border-color（颜色） border-style（样式） 没有顺序要求 去掉边框：border：none； border-style可选值：none（默认值），solid（实线），dotted（点状）dashed（虚线），double（双线） 用border-width举例，其他的边框样式也是一样的规则 border-width：上，右，下，左（顺时针） border-width：上，左右，下 border-width：上下，左右 border-width：四边 border-xxx-width，xxx可以是top,bottom,left,right 也可以是border-xxx单独设置某一边的width，color，style 去掉某一边的样式，border-xxx：none 内边距：内容与边框之间的距离padding-xxx：xxx可以是top,bottom,left,right也可以简写成padding，规则与上面width一致 外边距：盒子与盒子之间的距离（影响的是盒子所处的位置）margin-xxx：xxx可以是top,bottom,left,right（设置为左、上影响的是该盒子的位置，设置为右、下影响的是其他盒子的位置。也可以设置为负值，反方向移动）也可以简写成margin，规则与上面width一致auto：自适应（将margin水平方向其中一方设置为auto，则会是该方向外边距的最大值，都设置为auto则会在父元素水平中居中显示。设置成垂直方向没有作用） margin：0 auto（水平居中显示） 垂直外边距的重叠（折叠）：（避免使用外边距而使用内边距）兄弟元素之间的相邻外边距会取最大值而不是求和父子元素之间的外边距也是相邻的，此时设置给子元素的外边距会自动传递给父元素，发生重叠（一起移动）。 去除相邻1：可以给父元素设置边框或者内边距，这样就可以单独设置其外边距，但这样盒子可见框会对应改变，需要重新设置盒子的大小。 - 去除相邻2：使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠。12345.box:before&#123; content: \"\"; /*display:table可以将一个元素设置为表格显示*/ display: table;&#125; 去除默认样式：浏览器会给某些元素设置默认的样式（但通配写法可能会误伤）1234*&#123; margin:0; padding:0;&#125; 4.1.2 内联元素： 不可设置宽高 可设置水平方向的内边距和边框，会影响页面布局 可设置垂直方向的内边距和边框，但不会影响页面布局 可设置水平方向的外边距，会影响页面布局 不可设置垂直方向的外边距 4.1.3 修改元素类型：块元素和内联元素之间的转换：display：block（块元素）| inline（默认值，行内元素）| inline-block（行内块元素）| none（隐藏元素，并且不占用位置）行内块元素：可设置宽高，不会独占一行（但是元素与元素之间自带距离） 隐藏元素： display：none（隐藏元素，并且不占用位置） visibility：visible（默认值，可见）| hidden（不可见，但占用位置） 溢出处理：子元素溢出父元素内容区 overflow：visible（可见，即不做处理）| hidden（修剪，即直接剪切）| scroll（添加滚动条，以查看完整内容，但此属性不论内容是否溢出都会添加双方向的滚动条）| auto（添加滚动条，以查看完整内容，此属性会添加对应方向的滚动条，不溢出则不显示滚动条） 文档流： 文档流处在网页的最底层，它表示的是一个页面中的位置 我们所创建的元素默认都处在文档流中 块元素在文档流中独占一行，默认自上向下排列（默认宽度是auto，即父元素的100%；默认高度被子元素撑开） 内联元素在文档流中只占自身大小，默认自左向右排列（一行不足以容纳则自动换行。其宽高默认被子元素内容撑开） 当元素的宽为auto时，设置内边距不会影响可见框的大小，而是会自动修改宽以适应内边距 浮动：float：none（默认值，依然在文档流中排列）| left（脱离文档流，往父元素的左上浮动依次排列）| right（脱离文档流，往父元素的右上浮动依次排列）| 一旦元素设置了浮动，即该元素脱离文档流，浮到父元素的上层，下层元素位置上移，即浮动之后上层元素会覆盖依然处于文档流的下层元素。 如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过它（解决方式可以是直接都设置浮动或者调换位置，使浮动元素处于上边）（IE6不管是不是块元素都不能超过） 浮动的元素不会盖住文字，文字会自动环绕在浮动元素周围（文字环绕图片效果） 块元素脱离文档流后，默认宽高被内容撑开 内联元素脱离文档流后，会转换成块元素 高度塌陷：当父元素为了自适应子元素高度而没有设置高度时，如果子元素设置了浮动，则父元素会出现高度塌陷的问题（即不能被子元素撑开且被子元素覆盖），然后父元素以下的元素会依次上移，导致页面布局出现混乱。 解决方式1：根据W3C的标准，在页面中元素都一个隐含的属性叫做BlockFormatting Context（块级格式化环境），简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当开启元素的BFC以后，元素将会具有如下的特性：1.父元素的垂直外边距不会和子元素重叠2.开启BFC的元素不会被浮动元素所覆盖3.开启BFC的元素可以包含浮动的子元素（即可以解决高度塌陷）如何开启元素的BFC：1.设置元素浮动2.设置元素绝对定位 使用这两种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题 3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 4.将元素的overflow设置为一个非visible的值推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。 但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中有另一个隐含的属性叫做hasLayout（有无布局），该属性的作用和BFC类似，所以在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：直接将元素的zoom设置为1即可zoom表示放大的意思，后边跟着一个数值，即将元素放大几倍zoom:1表示不放大元素，但是通过该样式可以开启hasLayout（IE6为元素设置宽度也可以开启hasLayout） 为了兼容各大浏览器，一般把两个样式都写上： 12overflow:hidden;zoom:1; 解决方式2：可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以可以撑开父元素的高度，然后再对其进行清除浮动元素带来的影响，这样可以通过这个空白的div来撑开父元素的高度（清除浮动元素带来的影响：其兄弟元素就是由于设置了浮动导致高度塌陷。而兄弟元素浮动会使空白div上移则会导致高度塌陷，所以还要清除浮动） 1&lt;div class=\"clear\"&gt;&lt;/div&gt; 123.clear&#123; clear:both;&#125; 这种方式会导致添加了多余的网页结构。 解决方式3（最推荐使用）：给浮动元素的容器添加一个clearfix的class，然后给clearfix添加一个:after伪元素实现在元素之后添加一个看不见的块元素清理浮动。原理与方式2是一样的，只是这样就不会产生多余的网页结构。 12345.clearfix:after&#123; content:\"\"; display:block; clear:both;&#125; 为了兼容IE6及以下的浏览器，需要再添加以下的代码打开hasLayout: 123.clearfix&#123; zoom:1;&#125; 解决方式4：（完善clearfix）12345678.clearfix:after&#123; content: \"\"; display: table;/*table也是块元素*/ clear: both;&#125; 通过以上代码我们可以发现解决父子元素的外边距重叠和父元素高度塌陷的方法类似，所以我们一般写在一起： 123456789.clearfix:before,.clearfix:after&#123; content: \"\"; display: table; clear: both;&#125;.clearfix&#123; zoom: 1;/*兼容IE6*/&#125; 清除浮动：一般是在兄弟元素之间：清除其他浮动元素对当前元素的影响（其他元素浮动，当前元素会上移，清除影响之后当前元素不再上移）clear：none（默认，不清除）| left（清除左侧浮动元素对当前元素的影响）| right（右侧）| both（两侧，实际上是清除对它影响最大的浮动元素的影响） 4.2 定位：position：static：默认值，元素没有开启定位 | relative：相对定位 | absolute：绝对定位 | fixed：固定定位（也是绝对定位的一种） 偏移量：开启定位后结合偏移量进行位置的移动left，right，top，bottom（规则：相对于定位位置进行偏移的量） 4.2.1 相对定位：1.开启相对定位不设置偏移量元素位置不会发生变化2.相对定位是相对于元素在文档流中原来的位置进行定位3.相对定位的元素不会脱离文档流4.相对定位会使元素提升一个层级（覆盖） 4.2.2 绝对定位：position:absolute1.开启绝对定位，会使元素脱离文档流（注意脱离文档流对应的变化）2.开启绝对定位不设置偏移量元素位置不会发生变化3.绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位）如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位4.绝对定位会使元素提升一个层级 position:fixed(固定定位)固定定位也是绝对定位的一种，继承了大部分特点，不同之处：固定定位永远都会相对于浏览器窗口进行定位固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动IE6不支持固定定位 4.3 层级：如果定位元素的层级是一样，则结构上是下边的元素会盖住上边的通过z-index属性可以用来设置元素的层级z-index：正整数（层级越高，越优先显示）对于没有开启定位的元素不能使用z-index，且父元素的层级再高，也不会盖住子元素 5. 透明度：opacity可以用来设置元素背景的透明，范围：0-1之间的值0 表示完全透明，1 表示完全不透明 opacity属性在IE8及以下的浏览器中不支持IE8及以下的浏览器需要使用如下属性代替filter: alpha(opacity=透明度)透明度范围：0-100之间的值，0 表示完全透明，100 表示完全不透明这种方式支持IE6，但是这种效果在IE Tester中无法测试 6.背景： 设置背景颜色：background-color 设置背景图片：语法：background-image:url(相对路径); 默认从图片的左上角开始显示，图片大于元素部分不显示，图片小于元素则将图片平铺以充满元素。 可以同时为一个元素指定背景颜色和背景图片，这样背景颜色将会作为背景图片的底色（一般情况下设置背景图片时都会同时指定一个背景颜色） 设置背景图片重复方式：background-repeat可选值：repeat，默认值，背景图片会双方向重复（平铺）no-repeat ，背景图片不会重复repeat-x， 背景图片沿水平方向重复repeat-y，背景图片沿垂直方向重复 一些渐变的图片（如导航条背景色）通常是一小张图片repeat-x显示出来的。 设置背景图片位置偏移量：background-position（背景图片默认是贴着元素的左上角显示）可选值： 该属性可以使用 top right left bottom center中的两个来指定一个背景图片的位置。如 top left 左上 center center 居中而如果只给出一个值，则第二个值默认是center。 也可以直接指定两个偏移量的值，第一个值是水平偏移量，第二个是垂直偏移量（正负值都可） 雪碧图（CSS-Sprite） 当我们设置图片按钮时（即通过切换图片以实现按钮的效果），会发现在第一次切换图片时，图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。 产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们的外部资源并不是同时加载，浏览器会在资源被使用才去加载资源。当我们把按钮图片设置成链接的时候，激活hover状态或者active状态才会加载相应的图片。由于加载图片需要一定的时间，所以在加载和显示过程会有一段空白时间，背景图片无法显示，导致出现闪烁的情况。 解决问题：可以将图片整合为一张图片，实现图片同时加载，就不会出现闪烁的问题了。然后再通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite） 优点：1.将多个图片整合为一张图片，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。2.将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。 设置背景图片是否随页面一起滚动：background-attachment 可选值：scroll，默认值，背景图片随着窗口滚动fixed，背景图片会固定在某一位置，不随页面滚动 不随窗口滚动的图片，我们一般都是设置给body，而不设置给其他元素，设置给其他会滚动的元素，该元素滚动没了会将图片也滚动没了。 当背景图片的background-attachment设置为fixed时，背景图片的定位永远相对于浏览器的窗口。（一定是在浏览器可显示部分） 简写：background通过该属性可以同时设置所有背景相关的样式。没有顺序的要求，也没有数量的要求，不写的样式就使用默认值。 7. 表格： 设置表格边框距离：border-spacing 设置表格的边框合并：border-collapse 1234567891011121314151617181920212223242526table&#123; width: 300px; margin: 0 auto;/*边框*//*border:1px solid black;*//*table和td边框之间默认有一个距离通过border-spacing属性可以设置这个距离*//*border-spacing:0px ;*//*border-collapse可以用来设置表格的边框合并如果设置了边框合并，则border-spacing自动失效*/border-collapse: collapse;/*设置边框*/td , th&#123; border: 1px solid black;&#125;/*设置隔行变色*/tr:nth-child(even)&#123; background-color: ;&#125;/*鼠标移入到tr以后，改变颜色*/tr:hover&#123; background-color: ;&#125; 表格布局：表格的列数由td最多的那行决定。表格是可以嵌套，可以在td中在放置一个表格。 以前表格更多的情况实际上是用来对页面进行布局的，但是这种方式早已被CSS所淘汰了，因为多次嵌套耦合度太高，且不利于搜索引擎检索。 8.CSS-Hack（不推荐使用）：CSS-Hack 实际上指的是一段特殊的代码，这段代码只在某些浏览器中可以识别，而其他浏览器不可以识别。（通常应用于浏览器兼容性问题，当无法实现完美兼容时，一般会写适应多个版本的css,而在HTML引用时用条件Hack进行判断分别引用不同css） 条件Hack：只对IE9及以下浏览器有效，其他的浏览器会对其识别为注释 12&lt;!--[if &lt;keywords&gt;? IE &lt;version&gt;?]&gt;&lt;![endif]--&gt; keywords:是否（什么都不写）大于（gt）大于或等于（gte）小于（lt）小于或等于（lte）非（！） version:版本 示例： 123&lt;!--[if lte IE 7 ]&gt;只在IE7及以下浏览器执行 &lt;![endif]--&gt; 属性级Hack： 在样式前加_(下划线)表示只有IE6及以下浏览器才可识别在样式前加*(下划线)表示只有IE7及以下浏览器才可识别 选择符级Hack： 在选择器前加* html 表示只有IE6可以识别 9. 设置光标样式：cursor：default（默认，箭头）| pointer（小手）| crosshair（十字）| move（移动） 10. IE6的双倍边距bug：在IE6中，当为一个向左浮动的元素设置左外边距或者为一个向右浮动的元素设置右外边距时这个外边距将会是设置的值的2倍 添加display：inline；来解决ie6的双倍边距问题对于一个浮动元素来说设置display:inline没有任何意义但是该样式可以解决IE6的双倍边距问题","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML学习笔记2","slug":"HTML学习笔记2","date":"2020-04-22T06:26:52.000Z","updated":"2020-04-22T06:35:31.910Z","comments":true,"path":"2020/04/22/HTML学习笔记2/","link":"","permalink":"http://yoursite.com/2020/04/22/HTML学习笔记2/","excerpt":"1. HTML简介：","text":"1. HTML简介： 超文本标记语言（Hypertext MarKup Language） 版本：在最上方添加doctype声明，告诉浏览器使用的HTML版本 html5的版本声明：&lt;！doctype html&gt; 2. HTML语法：2.1 标签： 根标签：&lt;html&gt;&lt;/html&gt;（一个页面中有且只有一个根标签） 子标签：12345&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; &lt;title&gt;:显示在浏览器的标题栏，搜索引擎在检索页面时，会首先检索title，会影响到页面在搜索引擎中的排名。 meta标签：设置网页的元数据，例如字符集，关键字，网页描述，请求的重定向。写法：&lt;meta name=”” content=”” /&gt;12&lt;meta http-equiv=\"refresh\" content=\"秒数;url=目标路径\" /&gt;&lt;!-- 请求重定向 --&gt; 搜索引擎检索页面时，会同时检索页面中的keywords和description，但不影响排名。 自结束标签，可以在末尾添加一个“/”也可以不要 语义化标签：因为是语义化标签，所以我们关心的不是其表现形式，而是其代表的语义。比如h1~h6，我们不关心其文字大小，而是其代表的层级关系。对于搜索引擎来说，h1的重要性仅次于title,会影响到页面在搜索引擎中的排名。一般只写一个h1,而h3以后的标题标签不使用。 空格与换行：在HTML中，字符间的空格与换行都会当成一个空格解析 特殊字符：&amp;实体名字；（转义字符串） 图片宽高：应交给美工裁剪，而不自己设置。属性：src（图片路径，可以是相对路径也可以是绝对路径）alt（图片描述，搜索引擎通过alt属性识别不同图片）width(宽度) height(高度) 路径：../:表示返回上一级目录，返回几级写几个../相对路径：相对于某个文件夹的位置（写在哪里就是相对于哪个文件夹）绝对路径：绝对地址 常见图片格式：JPEG(JPG):一般用于保存照片等颜色丰富的图片（可压缩）GIF:一般用于保存颜色单一的图片或者动态图片PNG:颜色复杂，支持透明 选择图片格式原则：效果一样，选择小的；效果不一样，选择好的 语法规范：一般使用小写；注释不嵌套；其他标签可以嵌套，不可交叉嵌套；结构完整（成对出现/自结束） 内联框架&lt;iframe&gt;：引入外部页面(不推荐使用，其内容不被搜索引擎所检索)属性：src（页面路径，可以是相对路径也可以是绝对路径）width(宽度) height(高度) name center标签：居中 注释： 1&lt;!-- 注释 --&gt; 所有纯表现的标签都不推荐使用，而推荐使用css。 超链接：地址不确定时，可以用“#”作为占位符,会自动回到页面顶部 发送邮件：href=”mailto:邮箱地址”，点击链接会自动打开计算机默认的邮件客户端，并且会将收件人设置为邮箱地址（现在一般是设置为二维码）属性：href（目标路径，可以是相对路径也可以是绝对路径） target(打开链接位置):_self(在当前位置打开),_blank(在新的窗口打开)，或者为iframe标签中的name属性(在内联框架中打开) &lt;em&gt;：强调语气上的着重点（表现为斜体）同样表现为斜体的还有&lt;i&gt;（无语义） &lt;strong&gt;：强调内容的重要性（表现为粗体）同样表现为粗体的还有&lt;b&gt;（无语义） &lt;small&gt;：表现为比父元素小一些在h5中用来表示一些细则类的内容。如合同小字，版权声明等 &lt;cite&gt;：用来表示引用参考的内容（表现为斜体）比如书，电影，话剧，歌等的名称。 &lt;q&gt;：短的引用，即行内引用（表现为加上双引号） &lt;blockquote&gt;：长的引用，即块级引用（表现为独占一行） &lt;sup&gt;：下标，比如幂，备注等 &lt;sub&gt;：上标，比如化学元素等 &lt;ins&gt;：下划线，插入内容（比如填空等） &lt;del&gt;：删除线，删除内容（比如降价等） &lt;pre&gt;：预格式 &lt;code&gt;：代码 一般&lt;pre&gt;与&lt;code&gt;结合使用来表示一段代码 &lt;span&gt;：span用来选中文字，为其设置样式 块元素：多用于网页布局。独占一行，可设置宽高（div,p,h1-h6,li,ul,ol,table…） 内联元素：只占自身大小，不可设置宽高，多用于选中文字设置样式（a,iframe,span…） 行内块元素：只占自身大小，可设置宽高（input） 2.2 文档流 所有的元素默认情况下都是在文档流中存在的 文档流是网页的最底层 元素在文档流中的特点： 块元素 1.默认宽度是父元素的全部（独占一行） 2.默认高度被内容（子元素）撑开 3.在页面中自上而下垂直排列 内联元素 1.默认高度和宽度都被内容撑开（只占自身大小） 2.在页面中自左向右水平排列，如果一行不足以容下所有的元素，则换到下一行继续从左向右 一般用块元素去包含内联元素a元素可以包含任意元素，除了本身p元素不可以包含任何块元素 2.3 属性： 属性：写在开始标签中，设置样式，结构：名值对 写法：属性名=“属性值” charset属性：字符集 12&lt;meta charset=\"utf-8\" /&gt; &lt;!--告诉浏览器网页所采用的编码字符集是utf-8--&gt; 全局属性：所有标签可以设置唯一标识：id（与标签配合使用，href=“#id名称”，会跳转到相应id位置）title ： 鼠标滑过会显示提示文字 2.4 乱码： 乱码：编码和解码所采用的字符集不同 （计算机是二进制编码，只识别0,1） 字符集：编码和解码（进制的转换）所采用的规则 常见的字符集：ASCII(美国),ISO-8859-1(欧洲),GBK（中国）,GB2312(中国系统默认编码),UTF-8(通用，国际性),ANSI(自动以系统的默认编码来保存文件) Unicode包括utf-8等 在中文系统的浏览器中，默认使用GB2312进行解码 进制：满几进1（进1即进位数） 二进制：0,110,11,100,101,110,111… 八进制：0,1,2,3,4,5,6,710,11,12,13,14,15,16,17,20,21… 十进制：0,1,2,3,4,5,6,7,8,910,11,12,13,14… 十六进制:0,1,2,3,4,5,6,7,8,9，a,b,c,d,e,f 使用a,b,c,d,e,f分别表示10,11,12,13,14,1510,11,12,13,14,15,16,17,18,19.1a,1b,1c… 2.5 列表：列表的type属性可以设置排序类型，但我们一般不用，因为不同浏览器显示效果不一致。甚至默认的我们也会取消掉（list-style：none），为了实现在所有的浏览器显示效果一致。然后通过为li设置背景图片的方式来体现排序类型。 &lt;ul&gt;：无序 导航条 &lt;ol&gt;：有序 type属性：1，A/a, I/i &lt;li&gt;：列表项 &lt;dl&gt;：定义列表 下拉菜单 &lt;dt&gt;：被定义的内容 &lt;dd&gt;：对定义内容的描述 列表间可以互相嵌套。 2.6 表格：1234567891011121314151617&lt;table&gt; &lt;!-- 表格头部，永远显示在表格的头部--&gt; &lt;thead&gt; &lt;!-- th表示标题--&gt; &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表格底部，永远显示在表格的底部（写在前面是为了方便编辑）--&gt; &lt;tfoot&gt; &lt;!-- tr表示行，td表示单元格，rowspan表示合并行--&gt; &lt;tr&gt;&lt;td rowspan=\" \"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt; &lt;!-- 表格主体--&gt; &lt;tbody&gt; &lt;!-- colspan表示合并列--&gt; &lt;tr&gt;&lt;td colspan=\" \"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 如果表格中没有写tbody，浏览器会自动在表格中添加tbody。并且将所有的tr都放到tbody中，所以注意tr并不是table的子元素，而是tbody的子元素。 2.7 表单：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!--表单的作用就是用来将用户信息提交给服务器的 --&gt;&lt;!--form标签中必须指定一个action属性，该属性指向的是一个服务器的地址,当我们提交表单时将会提交到action属性对应的地址--&gt;&lt;form action=\" \"&gt;&lt;!--在表单中可以使用fieldset来为表单项进行分组--&gt; &lt;fieldset&gt; &lt;!-- 在fieldset可以使用legend子标签，来指定组名 --&gt; &lt;legend&gt;用户信息&lt;/legend&gt; &lt;!-- 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性 name表示提交内容的名字（后台通过name名获取到相应的值） 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器，即url地址?查询字符串 查询字符串格式：属性名=属性值&amp;属性名=属性值... --&gt; &lt;!-- label标签专门用来选中表单中的提示文字的（方便为其设置样式） 该标签可以指定一个for属性，该属性的值与表单项的id值（input的id值）一致 当我们点击提示文字也可以选中相应的项（获取焦点） --&gt; &lt;!--表单项 input是自结束标签 文本框type=\"text\"--&gt; &lt;label for=\"username\"&gt;用户名&lt;/label&gt; &lt;input id=\"username\" type=\"text\" name=\"username\" value=\"默认值\" placeholder=\"提示文字（水印）\"/&gt; &lt;!--密码框type=\"password\"--&gt; &lt;label for=\"pwd\"&gt;密码&lt;/label&gt; &lt;input id=\"pwd\" type=\"password\" name=\"password\" /&gt; &lt;br /&gt;&lt;br /&gt; &lt;!--文本域&lt;textarea --&gt; 自我介绍 &lt;textarea name=\"info\"&gt;&lt;/textarea&gt; &lt;/fieldset&gt; &lt;fieldset &gt; &lt;legend&gt;用户详情&lt;/legend&gt; &lt;!--单选按钮type=\"radio\" 单选按钮通过name属性进行分组，name属性相同是一组按钮 像这种需要用户选择但是不需要用户直接填写内容的表单项， 还必须指定一个value属性，这样被选中的表单项的value属性值将会最终提交给服务器 默认选中：checked=\"checked\" 默认不可用：disabled=“disabled” --&gt; 性别 &lt;input type=\"radio\" name=\"gender\" value=\"male\" id=\"male\" /&gt;&lt;label for=\"male\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"female\" id=\"female\" checked=\"checked\"/&gt;&lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;!--多选框 type=\"checkbox\" --&gt; 爱好 &lt;input type=\"checkbox\" name=\"hobby\" value=\"\" /&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"\" disabled=\"disabled\"/&gt; &lt;input type=\"checkbox\" name=\"hobby\" value=\"\" checked=\"checked\" /&gt; &lt;/fieldset&gt; &lt;!--下拉列表&lt;select&gt; 列表项&lt;option&gt; 下拉列表的name属性需要指定给select，而value属性需要指定给option 可以通过在option中添加selected=\"selected\"来将选项设置为默认选中 当为select添加一个multiple=\"multiple\"，则下拉列表变为一个可多选的下拉列表 --&gt; 喜欢的动漫： &lt;select name=\"cartoon\"&gt; &lt;!--在select中可以使用optgroup对选项进行分组，可以通过label属性来指定分组的名字--&gt; &lt;optgroup label=\"日漫\"&gt; &lt;option value=\"hy\"&gt;火影&lt;/option&gt; &lt;option value=\"hzw\"&gt;海贼王&lt;/option&gt; &lt;option value=\"kn\"&gt;柯南&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"国漫\"&gt; ...... &lt;/optgroup&gt; &lt;/select&gt; &lt;!-- 提交按钮 type=\"submit\" 可以将表单中的信息提交给服务器 在提交按钮中可以通过value属性来指定按钮上的文字 --&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;!--重置按钮type=\"reset\" 点击重置按钮以后表单中内容将会恢复为默认值 --&gt; &lt;input type=\"reset\" /&gt; &lt;!--普通按钮：type=\"button\" 这个按钮没有任何功能，只能被点击（一般用来调用JavaScript） --&gt; &lt;input type=\"button\" value=\"按钮\" /&gt; &lt;!-- 按钮：&lt;button&gt; 当设置了type属性，与input设置的按钮功能一致，更推荐使用 --&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;button type=\"button\"&gt;按钮&lt;/button&gt;&lt;form&gt; 2.8 框架集：框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面，框架集可以同时引入多个页面，而内联框架只能引入一个。（都只能用于引入其他页面，没有其他作用） 在h5标准中，推荐使用框架集，而不使用内联框架。 注意frameset不能和body出现在同一个页面中。属性：rows，指定框架一行一行的排列cols， 指定框架一列一列的排列这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小 在frameset中使用frame子标签来指定要引入的页面引入几个页面就写几个frame（自结束标签） frameset中也可以再嵌套frameset。 frameset和iframe一样，它里边的内容都不会被搜索引擎所检索，且我们每单独加载一个页面，浏览器就需要重新发送一次请求，用户的体验比较差。如果非得用（如公司内部网站）建议使用frameset而不使用iframe。 2.9 图片(png兼容IE问题)：在IE6中对图片格式png24支持度不高，如果使用的图片格式是png24，则会导致透明效果无法正常显示。 解决方法：1.可以使用png8来代替png24，即可解决问题，但是使用png8代替png24以后，图片的清晰图会有所下降2.使用JavaScript来解决该问题，需要向页面中引入一个外部的JavaScript文件 1234&lt;script type=\"text/javascript\" src=\" \"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; DD_belatedPNG.fix(\"img\");&lt;/script&gt;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"进制","slug":"进制","date":"2019-12-19T13:17:24.000Z","updated":"2020-04-22T07:00:40.359Z","comments":true,"path":"2019/12/19/进制/","link":"","permalink":"http://yoursite.com/2019/12/19/进制/","excerpt":"进制：进位计数制，是人为定义的带进位的计数方法。x进制就是逢x进位。","text":"进制：进位计数制，是人为定义的带进位的计数方法。x进制就是逢x进位。 1. 分类：1.1 二进制：Binary，简写为B。以2为基数，通常用两个不同的符号0（代表零）和1（代表一）来表示。每个数字称为一个比特（Bit，Binary digit的缩写）。 1.2 八进制：Octal，简写为O。首数字必须为0。以8为基数，采用 0 ~ 7 八个数字，逢八进1。 1.3 十进制：Decimal，简写为D。以10为基数，采用 0 ~ 9 十个数字，逢十进1。 1.4 十六进制：Hexadecimal，简写为H。十六进制用0x开头。以16为基数，一般用数字0到9和字母A到F（或a ~ f）表示，其中:A ~ F表示10 ~ 15，逢十六进1。 2. 进制转换：2.1 十进制转换为x进制：十进制整数采用“除x倒取余”。 十进制小数采用“乘x取整，顺序排列”（精度自定义）。小数的整数部分同上。 2.2 x进制转化为十进制：把x进制数按权展开,相加即得十进制数。 2.3 二进制转换为八进制：从右到左，每三位取成一位（每个八进制为3个二进制），不足时最左边补0，每一位再按权展开，得到的数。 2.4 八进制转换为二进制：除2取余法，从右到左得到二进制数，每个八进制为3个二进制，不足时最左边补0，最终的二进制数最左边有0则去掉。 2.5 二进制与十六进制的转换：与上面是类似的，只是每个十六进制为4个二进制。 2.6 八进制与十六进制的转换：先转换成其他进制，再进行转换。 3. 补充：进制分类： 进制：满几进1（进1即进位数） 二进制：0,110,11,100,101,110,111… 八进制：0,1,2,3,4,5,6，710,11,12,13,14,15,16,17,20,21… 十进制：0,1,2,3,4,5,6,7,8,910,11,12,13,14… 十六进制:0,1,2,3,4,5,6,7,8,9，a,b,c,d,e,f 使用a,b,c,d,e,f分别表示10,11,12,13,14,1510,11,12,13,14,15,16,17,18,19.1a,1b,1c… js中表示进制：进制的数字的表示： 0b 开头表示二进制，但是不是所有的浏览器都支持 0 开头表示八进制 0x 开头表示十六进制","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"进制","slug":"进制","permalink":"http://yoursite.com/tags/进制/"}]},{"title":"用hexo搭建个人博客","slug":"用hexo搭建个人博客","date":"2019-11-12T09:17:23.000Z","updated":"2019-11-12T13:44:30.910Z","comments":true,"path":"2019/11/12/用hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/11/12/用hexo搭建个人博客/","excerpt":"前言：","text":"前言： 系统：Windows博客框架：hexo应用主题：yilia托管到：GitHub 1. 搭建个人博客到本地预览：简介：hexo是一种博客框架，基于nodejs，git环境，使用Markdown作为渲染引擎解析文章。 nodejs环境 安装git：官网下载 注意要将git配置到环境变量中： 安装hexo: 借助npm安装，但国内下载速度太慢，先安装cnpm（淘宝镜像）提高安装速度，然后再用cnpm安装其他 然后用cnpm安装hexo:cnpm install -g hexo-cli 验证是否安装成功：hexo –v 新建项目： 新建文件夹如blog，该文件夹是项目的路径: 指令：mkdir + 文件夹名或者直接到相关路径下右键新建文件夹； 进入该文件夹，用hexo 新建一个博客（注意要用管理员身份运行）： hexo init （init即初始化一个博客）； 初始化博客失败的话就把文件夹blog删掉重来一遍。（查看文件夹目录：dir） 启动博客，即运行服务器: hexo server（简写hexo s） 新建文章，即新建md文件：hexo n + &quot;文件名&quot; 可用typora编辑md文件（Typora是一款Markdown编辑器） 生成文件：hexo g(hexo generate) 在本地可以预览到博客页面效果： 2. 将博客部署到远端（github）上： 打开github，创建仓库（repository） 用户部署个人博客的github仓库命名：github用户名.github.io（git用户名与GitHub用户名应一致） 在blog下安装git的一个部署插件：cnpm i hexo-deployer-git --save 相关配置：打开blog下的_config.yml文件，配置type，repo，branch repo(仓库地址)： 配置的时候冒号后要加上空格！ 将博客部署到github上： 首先，如果没有设置git 的user name和email，需要在git bash进行相关设置： 然后，部署到远端命令：hexo d(hexo deploy)部署成功后可以在GitHub看到相关内容，并且通过网址访问博客：https://clownna.github.io/ 3. 更换博客主题： 下载主题（自行选择）： 在blog文件夹下运行命令：git clone + 主题网址.git + themes/yilia(themes/yilia是下载放置地址) 如下载主题yilia：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 将主题应用到博客： 修改blog下的_config.yml文件：将theme中的内容改成yilia（同样注意空格） 然后就可以重新启动hexo ,一般以下这四步操作： hexo clean：清理缓存 hexo g：生成文件 hexo s：启动博客 hexo d: 部署到远端 4. 优化博客主题（以yilia为例）：4.1 assets/img： 存放图片资源（放在根目录或者主题目录下都行） 然后直接在主题配置文件下进行引用，示例如下： 4.2 修改站点配置文件： 即博客blog根目录下的_config.yml文件： 修改语言：language： zh-CN 修改作者：author: clownna（自定义） 修改标题：title: Clownna（自定义） 首页分页：一页显示多少篇文章预览 分类分页：一页显示多少篇文章预览 “所有文章”按钮的安装： 1、请确保node版本大于6.2； 2、在博客根目录（注意不是yilia根目录）执行以下命令：npm i hexo-generator-json-content --save 3、在根目录_config.yml最下面添加配置：123456789101112131415161718jsonContent: meta: false pages: falseposts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 4.3 修改主题配置文件： 即主题yilia目录下的_config.yml文件：","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"CSS学习笔记","slug":"CSS学习笔记","date":"2019-10-28T12:05:16.000Z","updated":"2019-11-13T14:31:14.150Z","comments":true,"path":"2019/10/28/CSS学习笔记/","link":"","permalink":"http://yoursite.com/2019/10/28/CSS学习笔记/","excerpt":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^","text":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^ 1. 简单介绍 CSS： 用来定义网页外观样式，英文全称是Cascading Style Sheet（层叠样式表或级联样式表）； 也是一种标识性语言，用于存放css样式的文件的扩展名后缀为.css; 允许同时控制多重页面的样式和布局，只要修改样式表文件可达到“换肤”效果； 实现内容和样式分离，简化格式代码，精确网页布局，且外部的样式表会被浏览器保存在缓存里，加快了下载显示的速度，提高工作效率； 最新版本CSS3： 带来了圆角，半透明，阴影，渐变，旋转，多背景图等新的特征； 加入了字体，颜色，布局，背景，定位，边框，多列，动画，选择器，用户界面等多个模块； 带来的媒体查询可以为不同的显示设备定义相匹配的样式； 2. PS: 基于书籍《HTML5+CSS3网页设计案例教程》以及网络资源","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML学习笔记","slug":"HTML学习笔记","date":"2019-10-27T14:16:00.000Z","updated":"2019-11-27T10:18:50.297Z","comments":true,"path":"2019/10/27/HTML学习笔记/","link":"","permalink":"http://yoursite.com/2019/10/27/HTML学习笔记/","excerpt":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^","text":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^ 1. 简单介绍：建议访问，有详细教程：菜鸟教程 | w3school HTML： 用来描述网页文档的一种超文本标记/标签语言，英文全称是Hyper Text Markup Language（超文本标记语言）; 纯文本文件，能用任意的文本编辑器编辑，如：记事本、写字板、 Word 、 Dreamweaver 、 Frontpage 等； 通过标记来标识要显示网页的各个部分，浏览器按顺序阅读网页文件，然后根据标记解释和显示网页内容； XHTML: 可扩展超文本标记语言 是一种增强了的HTML，XHTML 是更严谨更纯净的 HTML 版本 所有元素，包括空元素，比如img、br等，也都必须闭合，实现的方式是在开始标签末尾加入斜扛，比如&lt;img … /&gt; 、&lt;br /&gt; 所有的标签必须小写 所有的参数值，包括数字，必须用双引号括起来 不可以省略参数，比如&lt;option selected&gt;必须用&lt;option selected=”selected”/&gt; 属性禁止简写，比如&lt;hidden=”hidden”&gt;必须用&lt;element hidden=”hidden”&gt; 详细差别：相关网站 HTML是一种基于标准通用标记语言（SGML）的应用，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集。国际上在网站设计中推崇的WEB标准就是基于XHTML的应用（即通常所说的CSS+DIV）。 最新版本HTML5： 新增了更多语义化标记：header,footer,section,article,aside,nav等; 新增了很多标识元素：canvas,audio,video等； 取消HTML4过时标记：字体&lt;font&gt;,框架&lt;frame&gt;,&lt;frameset&gt;等； 在书写上更加简便： 某些元素可以省略结束标签 某些元素不用正确闭合标签 属性值可以不用引号括起来 标签不再区分大小写 某些标志性的属性可以省略属性值，通常为 boolean 类型 一些全新的表单输入对象，如URL,Email等； 支持本地数据库； 对移动应用程序和游戏方面的支持； 可以跨平台使用，具有良好的移植性； 跨平台使用：应用（如程序语言）可以在多种系统下开发，运行和维护； 可移植性：程序可以在不同平台上使用，只需改动部分代码（实现本质：使用标准库函数；尽可能使所写的程序适用于所有的编译程序；分模块编程，使改写(重写)程序的工作变得轻易）； HTML5 API： 相关网站 API：应用程序编程接口，是一组定义、程序及协议的集合，通过 API接口实现计算机软件之间的相互通信。API 的一个主要功能是提供通用功能集。API同时也是一种中间件，为各种不同平台提供数据共享。 编译程序也称为编译器，是指把用高级程序设计语言书写的源程序，翻译成等价的机器语言格式目标程序的翻译程序。 2. HTML文档： 文件名一般使用英文字母、数字或下划线，不要使用特殊字符，不要使用空格； 首页文件一般命名为index.html或者index.htm；基本构造： 12345678910111213&lt;!-- &lt;html&gt;:表示包含的内容为HTML文档 --&gt;&lt;!-- !DOCTYPE：表示文档类型 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- 声明当前页面的语言类型,如中文 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;!-- 头部 --&gt;&lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;!-- 主体 --&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; charset 属性是 HTML5 中的新属性，且替换了：&lt;meta http-equiv=”Content-Type” content=”text/html; charset=UTF-8”&gt; ，简写了代码。charset 属性可以通过任意元素上的 lang 属性来重写。 3. HTML语法：3.1 HTML标记： 用于描述功能的符号称为“标记”或“标签”； 单标记： &lt;标记 /&gt;，斜杆表示正确闭合； 双标记： &lt;标记&gt;内容&lt;/标记&gt;，成对出现，分为始标记和尾标记，中间添加内容； 标记可以成对嵌套，不可以交叉嵌套； 3.2. HTML属性： 属性是对标记的必要说明，一般要为属性赋值； 属性均放在相应标记的尖括号内，属性之间用空格隔开； 属性之间没有前后顺序； 属性值用一对双引号括起来； 全局属性：可用于任何HTML5元素； 属性 属性值 描述 accesskey 字符 规定访问元素的键盘快捷键(获取焦点) class 类名 规定元素的类名 contenteditable true，false 规定是否允许用户编辑内容 contextmenu &lt;menu&gt;元素的id 当用户右击元素时将显示上下文菜单 data-* 自定义值 用于存储页面的自定义数据 dir ltr或rtl 规定元素中内容的文本方向 draggable true，false，auto 规定是否允许用户拖动元素 dropzone copy，move，link 规定被拖动数据拖动到元素中会发生什么 hidden hidden 规定对元素进行隐藏 id id名称 规定元素的唯一id（通常用于指向样式表的id） lang 语言代码 设置元素中内容的语言代码 spellcheck true，false 检测元素是否拼写错误 style 一个或多个由分号分隔的 CSS 属性和值 规定元素的行内样式（inline style） tabindex 数字 设置Tab键获取页面中元素焦点的次序 title 文本信息 规定元素的额外信息 translate yes，no 指定一个元素的值在页面载入时是否需要翻译 加粗为HTML5 新增属性 accesskey:不同操作系统不同浏览器使用快捷键前缀不同： class : 通常用于指向样式表的类。但是，它也可以用于 JavaScript 中（通过 HTML DOM）, 来修改 HTML 元素的类名。HTML 元素允许使用多个类，用空格分隔类名。 当元素中没有设置 contenteditable 属性时，元素将从父元素继承。 目前只有 Firefox 浏览器支持 contextmenu 属性。 dir：ltr为默认从左到右，rtl为从右到左。 draggable：auto为使用浏览器默认特性，链接和图像默认是可拖动的。 目前没有主流浏览器支持 dropzone 属性。 lang: 语言代码参考手册 spellcheck可对以下文本进行拼写检查：类型为 text 的 input 元素中的值（非密码）,textarea 元素中的值,可编辑元素中的值。 tabIndex的值可为-1至32767之间的任意数字，-1排除在Tab键的序列之外，0 排列在所有指定tabIndex的控件之后（默认值为0，即不定义tabIndex属性，则根据在源代码的位置进行排序），大于0的tabIndex值设定其Tab键顺序。 目前没有主流浏览器支持 translate 属性。 全局事件属性：插入 HTML元素中，以定义事件行为（比如当用户点击某个元素时启动一段JavaScript） 3.3 &lt;head&gt; 用于说明网页文档头部的相关信息，放在&lt;head&gt;元素内部： &lt;title&gt;: 标题（必需，只有一个）： 定义浏览器工具栏中的标题 提供页面被添加到收藏夹时的标题 显示在搜索引擎结果中的页面标题 &lt;meta&gt;：定义元数据，不显示在网页中。HTML文档可以有多个&lt;meta&gt;标记。 常用元数据： 字符集charset：定义网页使用的字符编码，如&lt;meta charset=&quot;UTF-8&quot; /&gt; 搜索引擎关键字：将name属性设置为keywords，示例：&lt;meta name=”keywords” content=”关键字，关键字，…” /&gt; 网页定时刷新或跳转：将http-equiv属性设置为refresh 刷新：&lt;meta http-equiv=”refresh” content=”秒数” /&gt; 跳转：&lt;meta http-equiv=”refresh” content=”秒数” url=”资源路径” /&gt; 扩展：相关网站 &lt;base&gt;：规定页面上所有相对链接的默认URL或默认目标（只能存在于 head 部分，只能有一个） 基本语法：&lt;base href=&quot; &quot; target=&quot; &quot; /&gt;（该属性会被每个链接中的 target 属性覆盖） &lt;link&gt;：定义文档与外部资源的关系，一般链接外部样式表。只能存在于 head 部分，可有多个 href：定义被链接文档的位置url hreflang：定义被链接文档中文本的语言 media：规定被链接文档将显示在什么设备上 rel：必需。定义当前文档与被链接文档之间的关系 属性值：图片来源 sizes：定义了链接属性大小，只对属性 rel=”icon” 起作用(HTML5新属性) type：规定被链接文档的 MIME 类型 &lt;style&gt;：定义 HTML 文档的样式信息。可有多个 media：为样式表规定不同的媒体类型 type：规定样式表的 MIME 类型 scoped：如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。&lt;style scoped=&quot;scoped&quot; /&gt;，指定了scoped的话style可以不用写在&lt;head&gt;内部。只有 Firefox支持 scoped 属性 。 &lt;script&gt;：定义客户端脚本，比如 JavaScript。既可包含脚本语句，也可以通过 “src” 属性指向外部脚本文件 async（HTML5新属性）：规定异步执行脚本，即当页面继续进行解析时，脚本将被执行（仅适用于外部脚本）&lt;script async=&quot;async&quot;&gt; defer：规定当页面已完成解析后，执行脚本（仅适用于外部脚本）。如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本。&lt;script defer=&quot;defer&quot;&gt; charset：规定在脚本中使用的字符编码（仅适用于外部脚本） src：规定外部脚本的 URL type：规定脚本的 MIME 类型 拓展：&lt;noscript&gt;，不支持 JavaScript 的浏览器显示内容（XHTML 不支持 &lt;noscript&gt; 标签） 4. 文字与段落： 空格：&amp;nbsp; 一个&amp;nbsp;占用一个英文字符的位置。 UTF-8编码：一个英文字符等于一个字节，一个汉字等于三个字节。 尽量不要使用&amp;nbsp;来表示多个空格，浏览器对空格的实现不一样。 常用特殊符号： 符号 代码 说明 &copy; &amp;copy; 版权符号 &reg; &amp;reg; 注册商标 &trade; &amp;trade; 商标（美国） &lt; &amp;lt; 左尖括号 &gt; &amp;gt; 右尖括号 &amp; &amp;amp; &amp;符号 添加注释：&lt;!-- 注释内容 --&gt; 换行：&lt;br /&gt;，多个&lt;br /&gt;表示多次换行 预先格式化：&lt;pre&gt;，可显示空格和换行示例： 段落：&lt;p&gt;：自动在其前后创建一些空白，形成段落 段落中出现多个空格或者换行也只会显示为一个空格 水平线：&lt;hr /&gt;：分隔内容 标题文字：&lt;h1&gt;–&lt;h6&gt;：&lt;h1&gt;定义最大标题，&lt;h6&gt;最小 强调文本： 粗体：&lt;b&gt; 斜体：&lt;i&gt; 插入：&lt;ins&gt;，表现为添加下划线 删除：&lt;del&gt; ，表现为添加删除线 &lt;u&gt;： 已废弃（&lt;u&gt; 元素被用来定义下划线） HTML5重定义与常规文本风格不同的文本，像拼写错误的单词或者汉语中的专有名词 &lt;s&gt;： 已废弃（&lt;s&gt;元素被用来定义删除线） HTML5 重定义不正确、不准确或者没有用的文本 小型文本：&lt;small&gt;，一般用于免责声明，注意事项，法律限制，版权声明，新闻来源，许可要求等 语义化、结构化的文本： 上标文本：&lt;sup&gt; 下标文本：&lt;sub&gt; 注音：中文或字符的&lt;ruby&gt;注释（&lt;rt&gt;定义其解释或发音）示例： 标注：&lt;cite&gt;，定义作品如书籍，歌曲，电影，电视，绘画，雕塑等的标题，呈现效果为斜体 定义日期时间：&lt;time&gt;基本语法：&lt;time datetime=&quot;&quot; pubdate=&quot;pubdate&quot;&gt;元素内容&lt;/time&gt;datetime属性：定义元素的日期时间，如果没有定义该属性，则必须在元素内容给出日期时间pubdate属性：是一个逻辑值，指示 &lt;time&gt; 元素中的日期/时间是文档（或 &lt;article&gt; 元素）的发布日期 其他语义化、结构化文本（格式化）： 标签 描述 &lt;em&gt; 被强调的文本 &lt;strong&gt; 重要的文本 &lt;dfn&gt; 定义项目 &lt;code&gt; 计算机代码文本 &lt;samp&gt; 计算机程序的样本文本 &lt;kbd&gt; 键盘文本（经常用在与计算机相关的文档或手册中） &lt;var&gt; 变量 &lt;blockquote&gt; 摘自另一个源的块引用（左右缩进） &lt;q&gt; 短的引用（插入引号） &lt;abbr&gt; 表示一个缩写词或者首字母缩略词 &lt;acronym&gt; 定义首字母缩略词（HTML5 不支持） &lt;address&gt; 作者/所有者的联系信息 &lt;ado&gt; 指定文本方向 如果是为了实现视觉效果更建议使用css &lt;code&gt;,&lt;samp&gt;和&lt;kbd&gt;呈现效果基本一致 &lt;blockquote&gt;和&lt;q&gt;都有属性值cite（规定引用的来源url） blockquote元素一般嵌套p元素 &lt;abbr&gt;(abbreviation)一般与title属性搭配使用，用来展示缩写词/首字母缩略词的完整版本；对缩写词语进行标记，就能够为浏览器、拼写检查程序、翻译系统以及搜索引擎分度器提供有用的信息 如果&lt;address&gt; 元素位于 &lt;body&gt;或者&lt;article&gt; 元素内部，则它表示该文档或者文章的作者/所有者的联系信息；通常被包含在 &lt;footer&gt; 元素的其他信息中。通常呈现为斜体，大多数浏览器会在该元素的前后添加换行。 &lt;ado&gt;属性值dir：ltr（left to right）以及rtl（right to left） 列表： 无序列表：&lt;ul&gt;标记，其列表项使用&lt;li&gt;标记 type=&quot;circle（空心圆点）| square（实心方形）| disc(默认实心圆点) | none &quot; 有序列表：&lt;ol&gt;标记，其列表项使用&lt;li&gt;标记 type=&quot;A | a | I | i | 1 （默认）&quot; 都是写第一个才有效，比如type=”A”而不可以是type=”B”，失效即显示默认效果 A或者a排序只到Z或者z，继续排会出现AA,AB…或者aa,ab…的情况 只有type=”1”时才有属性start，如从10开始排序，start=”10” 定义列表：用于定义术语，没有数字和符号的缩排列表，&lt;dl&gt;标记，&lt;dt&gt;标记定义列表项，&lt;dd&gt;标记定义描述列表中的项目 嵌套列表：可以是列表自身的嵌套，也可以是无序和有序列表互相的嵌套示例： 注音效果图为支持ruby元素显示效果，不支持的话会显示为：注音（Zhu Yin） 目前所有主流浏览器都不支持 &lt;time&gt; 标签 联想记忆： 粗体效果：粗体&lt;b&gt;,着重&lt;strong&gt;以及css的font-weight：bolder(特粗体) 斜体效果：强调&lt;em&gt;，斜体&lt;i&gt;，定义项目&lt;dfn&gt;，变量&lt;var&gt;，作者/所有者的联系信息&lt;address&gt;，作品标题&lt;cite&gt; 下划线效果：插入&lt;ins&gt;，特殊文本&lt;u&gt; 删除线效果：删除&lt;del&gt;，错误文本&lt;s&gt; &lt;del&gt; 和 &lt;ins&gt; 一起使用，描述文档中的更新和修正；它们有两个属性：cite（规定一个解释了文本被插入/删除的原因的文档的 URL）,datetime（规定文本被删除的日期和时间） datetime属性值：YYYY-MM-DDThh:mm:ssTZDYYYY - 年，MM - 月（例如 01 for January），DD - 日，T - 必需的分隔符，hh - 小时 （例如 22 for 10.00pm），mm - 分钟 ，ss - 秒 ，TZD - 时区标志符 HTML5新增标记加粗 5. 网页多媒体元素：HTML5新增了元素&lt;video&gt;，&lt;audio&gt;，&lt;embed&gt;，&lt;figure&gt;和&lt;figcation&gt;，改变了以外在网页中插入多媒体元素需要第三方控件的局面。 5.1 图像&lt;img&gt;: &lt;img&gt;：为被引用的图像创建占位符； 支持格式：JPEG（JPG）,GIF（支持动画和背景色透明）,PNG（支持背景透明）等 GIF，PNG占位储存空间较小，但GIF图片色彩质量受限，PNG在网页设计中最广泛使用 src：图像资源属性 基本语法：&lt;img src=&quot;url&quot;&gt; url：指明网页中要引用图像的位置，也就是引用图像文件的相对路径或绝对路径； 绝对路径：指向另一个网站的网址相对路径 ：指向网站内的一个文件（相对于网页文件的路径） 同一目录：输入图像全名 上一目录：../表示向上一级目录 下一目录：/表示向下一级目录 alt：图像替代文本（当图像失效显示或鼠标滑过显示） width和height：图像的宽高（像素|百分百） 设置这些属性，是为了在页面加载时会为其预留出空间（布局）。 但不能用于缩放，正确做法是在网页使用图像之前，先处理好图像。 5.2 视频&lt;video&gt;: 支持格式：MP4（最常用，适用性较强）,OGG,WEBM src：同上&lt;img&gt; controls：视频播放控件属性，是否为视频添加浏览器自带的播放控制条（播放按钮，播放进度，播放音量等控件） autoplay：视频在加载就绪后自动播放（使用此属性则忽略preload属性） preload：视频准备播放控件，在页面加载时就加载视频，并且准备播放，三个属性值： auto：当页面加载后加入整个视频 metadata：当页面加载后只加载媒体的元数据 none：当页面加载后不载入视频效果区别： loop：循环播放 muted：视频的音频输出为静音 poster：视频珈载时显示的图像，或者在用户点击播放按钮前显示的图像 width：视频宽度； height：视频高度；属性值：像素 基本语法：&lt;video src=&quot;url&quot; controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; muted=&quot;muted&quot; poster=&quot;url&quot;&gt;...&lt;/video&gt;``&lt;video src=&quot;url&quot; controls autoplay loop muted poster=&quot;url&quot;&gt;...&lt;/video&gt; 5.3 音频&lt;audio&gt;: 支持格式：MP3（最常用，适用性较强）,OGG,WAV,AAC 属性与&lt;video&gt;基本相同，少了width,height,poster 5.4 &lt;source&gt; source的作用就是为媒介元素（如&lt;video&gt;,&lt;audio&gt;）定义媒介资源 媒介元素可以指定多个source元素，按顺序检测是否可以播放 用于兼容不同的浏览器 属性： src： 规定媒体文件的 URL type：规定媒体资源的 MIME 类型 media：规定媒体资源的类型，供浏览器决定是否下载 基本语法示例： 12345&lt;video&gt; &lt;source src=\"url\" type=\"video/mp4\" /&gt; &lt;source src=\"url\" type=\"video/ogg\" /&gt; 您的浏览器不支持 video 元素。&lt;/video&gt; 几乎所有的主流浏览器都不支持 source–&gt;media 属性。 MIME 类型：描述并标记多媒体内容。当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。 Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型。当 Web 浏览器从服务器中取回一个对象时，会去查看相关的 MIME 类型，看看它是否知道 应该如何处理这个对象。来源 MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。具体参考：MIME 参考手册 5.5 多媒体文件&lt;embed&gt; &lt;embed&gt;元素可以插入多种格式的多媒体文件（效果：新建下载任务） 属性：src（url），width,height（宽高），type（ MIME 类型） 一般用于插入flash（.swf）动画：&lt;embed src=&quot;xxx.swf&quot; width=&quot; &quot; height=&quot; &quot;/&gt; 5.6 对象&lt;object&gt; 支持多种不同的媒介类型 data属性：规定对象使用的资源的 URL type属性：规定其MIME 类型 form属性：属性值form_id，规定对象所属的一个或多个表单 name属性：为对象规定名称 width，height属性：规定对象的宽高 可在页面中嵌入一个网页：&lt;object type=&quot;text/html&quot; data=&quot;url&quot; width=&quot; &quot; height=&quot; &quot;&gt;&lt;/object&gt; 5.7 媒介分组和标题&lt;figure&gt;/&lt;figcation&gt; &lt;figure&gt; 规定独立的流内容 可以是图片，图表，代码等等 &lt;figcation&gt; 定义&lt;figure&gt;的标题 放在&lt;figure&gt;的第一个或最后一个子元素的位置，且只能有一个&lt;figcation&gt; 可以是文字说明，图片备注 使用&lt;figure&gt;/&lt;figcation&gt;的好处是方便应用CSS，如同一个盒子元素示例代码：1234&lt;figure&gt;&lt;figcaption&gt;标题(只能有一个)&lt;/figcaption&gt;...(其他元素，可无限放置)&lt;/figure&gt; 各种浏览器支持的音视频格式不一样，注意考虑：浏览器支持性问题 可以在标签之间放置文本内容，不支持此元素的浏览器就可以显示出该标签的信息 6. 超链接 JavaScript链接：&lt;a href=&quot;javascript:alert(&#39;hello world!&#39;);&quot;&gt;点击出现弹窗&lt;/a&gt; 空链接写法：1234567&lt;!-- 空链接写法1：js写法，点击时没有任何操作--&gt;&lt;a href=\"javascript:void(0)\"&gt;空链接&lt;/a&gt;&lt;!-- 空链接写法2：--&gt;&lt;a href=\" \"&gt;空链接&lt;/a&gt;&lt;!-- 空链接写法3：--&gt;&lt;a href=\"#\"&gt;空链接&lt;/a&gt;&lt;!--写法2和写法3点击时会回到顶部，可理解为锚点--&gt; 7. 表格 8. 表单 后记：^ _ ^ 其实去菜鸟，w3school等网站都可以找到详细教程，为什么还是自己整理了笔记呢？一方面是因为笔记这种东西其实会有很强的“个人风格”，带有自己的叙述方式以及个人理解，感觉以后翻阅起来更加舒服（有种个人素材库的感觉哈哈）；另一方面是因为整理笔记的过程也算是一次复习吧，而且像这样敲打一遍感觉记忆会更加深刻；再者就是记录自己学习的过程啊哈哈~ ^ _ ^ PS: 基于书籍《HTML5+CSS3网页设计案例教程》以及网络资源","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"网页设计基础知识","slug":"网页设计基础知识","date":"2019-10-20T11:21:49.000Z","updated":"2019-11-13T14:32:15.303Z","comments":true,"path":"2019/10/20/网页设计基础知识/","link":"","permalink":"http://yoursite.com/2019/10/20/网页设计基础知识/","excerpt":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^","text":"前言：^ _ ^ 整理一下以前乱七八糟的笔记哈哈，以后要查找浏览就方便多啦~ ^ _ ^ 1. 网页相关知识：1.1 互联网、因特网、局域网、万维网 计算机网络（network）：连接分散计算机设备，以实现资源共享和信息传递的计算机系统。 互联网： 又称国际网络，凡是能彼此通信的设备组成的网络（可以仅是两台可以彼此通信的机器组成的网络） 写法：internet （i小写） 网络与网络之间所串连成的庞大网络，这些网络以一组通用的协议相连 因特网：互联网的一种，是由上千万台设备组成的互联网 写法：Internet（I 大写） 由计算机、网线（联系通道）、网络互联设备（交换机、路由器等，充当信息中转站）组成 它是一个信息资源和资源共享的集合 局域网（LAN）：局部地区形成的一个区域网络，覆盖范围一般是方圆几千米之内 局域网之间的通信协议必须是相同的 无线局域网（WLAN）:俗称WIFI的IEEE 802.11是当前最常见的一种无线局域网通信协议标准 有线局域网：俗称以太网的IEEE 802.3是当前最常见的一种有线局域网通信协议标准 区别广域网（WAN）：是指远距离的、大范围（跨地区、跨城市、跨国家）的计算机网络 Internet是全球最大的广域网，它覆盖的范围遍布全世界 万维网（WWW，全球网）：是Internet上集文本、声音、图像、视频等多媒体信息于一身的全球信息资源网络（万维网是通过互联网获取信息的一种应用） 基于TCP/IP（是指能够在多个不同网络间实现信息传输的协议簇）实现 TCP/IP由很多协议组成，不同类型的协议放在不同的层 最底层：网络层协议：IP协议，用于报文交换网络的一种面向数据的协议 上一层：运输层协议：UDP协议和TCP协议，它们用于控制数据流的传输 最顶层：应用层协议，这些协议定义了一些用于通用应用的数据报结构，包括： DNS：域名服务 FTP：服务使用的是文件传输协议 HTTP：所有的Web页面服务都是使用的超级文本传输协议 POP3：邮局协议 SMTP：简单邮件传输协议 Telnet：远程登陆等 WWW的网页文件是超文本标记语言HTML编写，并在超文件传输协议HTTP支持下运行 WWW的浏览器是一个客户端的程序，其主要功能是使用户获取Internet上的各种资源 之所以在浏览器输入网址时，能看见某网站提供的网页，就是因为浏览器和某网站的服务器之间使用的是HTTP在交流。 关系图： 1.2 网站、网页、浏览器、URL 网站（Website）：展示特定内容的相关网页的集合 网页： 静态网页：纯粹用html语言编写的网页，不能在服务器端运行，没有数据库支持，交互性相对较差；每个网页都有一个固定的url，且以.htm、.html、.shtml、.xml等常见形式为后缀；独立存在，内容相对稳定，容易被搜索引擎检索。 动态网页：以数据库为基础，能在服务器端运行；可以实现的功能较多，如用户注册、登陆、在线调查、用户管理、订单管理、站内搜索、歌曲下载、软件下载、即时更新新闻、可以留言或书写评论等；不独立存在，只有当用户请求服务器时才返回一个完整的网页。 动态网页一般会包含静态网页的内容，静态网页不能包含动态网页的内容。 浏览器：万维网服务的客户端浏览程序，可向万维网服务器发送各种请求，并对从服务器发来的超文本信息和各种多媒体数据格式进行解释、显示和播放 URL（即统一资源定位器）：网址，用于标识网页文件在网络上的位置（URL地址也可以是本地磁盘，或是局域网上的某一台计算机） 一个完整网址由通信协议名称、域名（包括后缀.com、.net、.org等）或IP地址、网页在服务器中的路径和文件名四部分组成： 网页浏览器：主要通过超文本传输协议HTTP进行交互 HTTP与HTTPS的区别： HTTP协议以明文方式发送内容，不提供任何方式的数据加密，不安全 为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，相对安全 SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密 IP地址：用来标识每台主机在互联网上的地址（由四个0~255的数字组成，数字之间用点分隔） 域名：用字符来标识主机地址的另一种方法 IP地址与域名的区别： 每一台计算机都有一个唯一的IP地址，一个域名可以有多个IP地址 使用域名或者IP同样可以访问网址，IP地址很难记，域名的作用之一就是方便记忆和提高辨识度 输入域名–&gt;域名解析服务器（dns）解析成其中一个IP地址–&gt;访问这个IP地址 一台计算机上面可以有好多个服务，也就是一个IP地址可以对应多个域名 举例：因为百度不止只有一台服务器，所以它有多个IP地址，这样访问起来会很乱，于是让所有的IP都映射到一个www.baidu.com (域名)，当我们访问域名的时候，就会由百度的负载均衡服务器来分配给一台服务器（即一个IP地址）来让用户访问。 示例： 2. 网页基本元素2.1 网页组成元素 网页的组成元素（最基本）：文本、图像、动画、超链接、视频、音频、表格和表单等 网页中使用的动画主要是GIF动画与Flash动画（一般浏览器中都嵌入插件Adobe Flash Player用来支持Flash动画的播放） 一个超链接由链接载体（文本，图片，图片的热区或热点）和链接目标（任意网络资源：其他网页，相同网页的不同位置，图片，电子邮件地址，文件，应用程序等）组成 用于网络的声音文件格式：MIDI、WAV（很多浏览器不用插件也可以）、MP3、RM（专门的浏览器）和AIF等 用于网络的视频文件格式：RM、WMV、ASF、MPEG、AVI、RMVB和DivX等 表单是网页中实现交互的元素，由不同功能的表单域（也叫表单控件，表单项等）组成，最简单的表单也要包含一个输入区域和一个提交按钮 2.2 网页构成元素 网页的构成要素：标题、页眉（站标Logo、站点名字图片、广告条、导航条和按钮等）、主内容区（重要内容排在左部和上部）、页脚（标注站点所属公司名称、地址、ICP备案、网站版权和制作者信息等）等 站标Logo规格有：（1）88×31:最普遍；（2）120×60：一般大小；（3）20×90：大型；（4）200×70：也已出现； 广告条Banner（宣传网站或替其他企业做广告）的常用尺寸：（1）长方形:常用类型，468×60（像素，下同）；（2）通栏广告：1000×177；（3）垂直矩形：侧面广告，110×300；（4）矩形：内部广告，300×140；（5）中等矩形：弹出窗口，400×430；（6）小矩形：浮动广告，80×80； 导航条：网站内多个栏目的超链接组合（整个网站的方向标，即目录） 按钮：功能性 3. 网站建设流程3.1 网站规划 主题风格、目标用户 结构设计 链接结构图:链接结构是指页面之间互相链接的拓扑结构 首页和一级页面之间用星状链接结构（一对多） 一级和以下各级页面之间用树状链接结构（一对一） 版面设计（布局） 显示器分辨率（网页兼容性） 常见版式布局： 左右形结构： 上下（吕）形结构： 厂（T）形结构： 同字形结构： 匡字形结构： 3.2 创建站点 站点：一组具有相关主题和类似设计的链接文档和资源。由以下三部分组成： 本地文件夹：即本地站点。工作目录。 远端文件夹：即远端站点。用户存储用于进行测试、协作、生产和部署等的文件的位置，一般位于运行web服务器的计算机上。 测试服务器文件夹：处理动态网页。 本地网站的浏览方式： “localhost”和”127.0.0.1”表示本地的意思，”80”是端口，由于默认就是80可以不写。 端口（Port）：设备与外界通讯交流的出口。网络端口：特指TCP/IP协议中的端口，是逻辑意义上的端口。（还有其他端口，略）常用端口之一：TCP 80=超文本服务器（Http)作用：一台主机可以提供许多服务,主机是通过“IP地址+端口号”来区分不同的服务的。 组织站点结构：素材归类整理 目录结构（建议使用）： html：存放html文档页面； css：存放css样式表文件； images：存放网站的图像文件； javascript：存放js脚本； library：存放库项目； media：存放多媒体文件； software：存放可下载的软件； sound：存放声音文件; templates：存放模板文件; 用英文或数字（不能放开头）命名，不能中文，空格，标点符号或特殊字符，尽量小写命名（Internet服务器采用UNIX操作系统时区分大小写）。 3.3 申请空间和域名 虚拟空间：互联网上的一台功能相当于服务器级的电脑或虚拟主机（24小时与因特网相连） 域名：唯一（识别作用） 总结：创建本地站点（本地网站）–&gt;申请空间和域名–&gt;调试（测试）–&gt;上传到web服务器（发布网站）–&gt;用户浏览–&gt;网站的推广和维护 后记：^ _ ^ 虽然只是一些概念性的知识，但感觉理解起来还是有点困难 QAQ …哈哈其实也不能说是困难吧，就是感觉只能算是对此有了一个浅显的了解，然后如果深入学习这些概念还是挺复杂的。^ _ ^ PS: 基于书籍《HTML5+CSS3网页设计案例教程》以及网络资源","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"网页设计","slug":"网页设计","permalink":"http://yoursite.com/tags/网页设计/"}]},{"title":"Markdown学习笔记","slug":"Markdown学习笔记","date":"2019-10-16T08:18:29.000Z","updated":"2019-11-13T14:32:44.686Z","comments":true,"path":"2019/10/16/Markdown学习笔记/","link":"","permalink":"http://yoursite.com/2019/10/16/Markdown学习笔记/","excerpt":"前言^ _ ^ 我开始写博客啦哈哈哈~ 然后是用hexo写的，它使用Markdown作为渲染引擎解析文章，所以就找时间学习了Markdown，这是学习笔记嘿嘿 ^ _ ^","text":"前言^ _ ^ 我开始写博客啦哈哈哈~ 然后是用hexo写的，它使用Markdown作为渲染引擎解析文章，所以就找时间学习了Markdown，这是学习笔记嘿嘿 ^ _ ^ 1. 简单介绍 Markdown 是一种轻量级标记语言。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 文档后缀名： .md或者 .markdown。 编辑器：可选择Typora （包含多种主题，编辑后直接渲染出效果。支持导出HTML、PDF、Word、图片等多种类型文件。） 2. Markdown语法2.1. Markdown标题使用 # 号标记:使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号,以此类推（注意：# 后面加上空格！）。 2.2. Markdown 段落Markdown 段落直接编写文字就好。段落的换行是使用两个以上空格加上回车，也可以在段落后面使用一个空行来表示重新开始一个段落。 2.3. Markdown 字体斜体文本： 在文字的两端加上 * 或 在文字的两端加上 _粗体文本: 在文字的两端加上 ** 或 文字的两端加上 __粗斜体文本: 在文字的两端加上 *** 或 在文字的两端加上 ___ （注意： * 或 _ 个数：斜体 &lt; 粗体 &lt; 粗斜体） 2.4. Markdown 分隔线你可以在一行中用三个以上的星号()、减号(-)、底线(_)来建立一个分隔线，*行内不能有其他东西**。你也可以在星号或是减号中间插入空格。如： * * * 2.5. Markdown 删除线删除线： 在文字的两端加上 ~~ 2.6. Markdown 下划线下划线： 通过 HTML 的 &lt;u&gt; 标签来实现，写法与HTML一样。 2.7. Markdown 脚注 2.8. Markdown 列表 Markdown 支持有序列表和无序列表 无序列表使用星号 * 或加号 + 或减号 - 作为列表标记 有序列表使用数字并加上 . 号来表示 列表嵌套： 只需在子列表中的选项添加四个空格（即制表符tab键） 任务列表：在[ ]中输入x表示完成，也可以通过点击选择完成或者未完成 注意：以基本符号 * - + &gt; 开头的标记，基本符号后有一个用于分割标记符和内容的空格！！ 2.9. Markdown 区块 在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号; 区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推退; 区块中可以使用列表 列表中可以使用区块（四个空格的缩进） 2.10. Markdown 代码 如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`） 示例： prinf(); 代码区块使用 4 个空格（制表符Tab 键） 示例： &lt;?php function test(){ echo &quot;Hello world!&quot; } test(); &gt; 指定一种语言（在段首指定） 123456&lt;?phpfunction test()&#123; echo \"Hello world!\"&#125;test();&gt; 2.11. Markdown 链接 方法一： 一个方括号，里面放上链接显示文字 接着一个普通括号，里面放上链接地址示例：Clownna的官方网站 方法二：一个尖括号，里面放上链接网址，这样的话链接显示文字即链接地址 https://clownna.github.io/ 方法三：用变量来代替 一个方括号，里面放上链接显示文字 接着一个方括号，里面放变量名称 然后在文档的结尾为变量赋值： 一个方括号，里面放变量名称 冒号，加上链接地址 文档尾补充： 示例：Clownna的官方网站 2.12. Markdown 图片 开头一个感叹号 ! 接着一个方括号，里面放上alt属性文本 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 title 属性的 文字。 也可以像链接那样对图片网址使用变量 （Markdown 还没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的&lt; img&gt; 标签。写法与HTML一样。） 2.13. Markdown 表格 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行 设置表格的对齐方式： -: 设置内容和标题栏居右对齐 :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐 示例： 2.14. Markdown 注释 支持HTML注释 hack方法：利用markdown的解析原理来实现注释 (引号也可以用括号代替) 空格！！！ 2.15. Markdown 表情使用规则：在表情对应的英文单词两边加上冒号 PS: 可以到相关网址查询其他更多表情 3.Markdown 高级技巧3.1. 支持的 HTML 元素 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写 目前支持的 HTML 元素有：等 3.2. 转义字符在特殊字符前加上反斜杠( \\ )，进行转义。 如上图，示例1是不会显示的，只有加上反斜杠( \\ )进行转义，才可以显示这些特殊字符。 扩展 使用vscode编写markdown的插件：Markdown Preview Enhanced:可以更加形象的展示所编写文档的pdf格式；Markdown TOC:自动插入目录，排序；Maridown PDF:将.md文件转换成其他格式(在编写.md文件的工作区直接右键即可看到由Maridown pdf插件产生的功能项，选择需要转换的格式即可生成需要的文件，生成的文件将会直接保存在.md的文件目录下。) 后记^ _ ^ 整体上来讲Markdown并不难，没什么理解性的东西，就是记住然后运用，再注意一下一些细节，基本上就可以掌握啦~ ^ _ ^ 参考网址","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}]